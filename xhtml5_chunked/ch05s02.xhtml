<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>RabbitMQ</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="prev" href="ch05.xhtml" title="Capítulo 5. Tecnologías"/><link rel="next" href="ch05s03.xhtml" title="MongoDB"/></head><body><header><div class="navheader"><table style="width: 100%; "><tr><th style="text-align: center; " colspan="3">RabbitMQ</th></tr><tr><td style="width: 20%; text-align: left; "><a accesskey="p" href="ch05.xhtml">Anterior</a> </td><th style="width: 60%; text-align: center; ">Capítulo 5. Tecnologías</th><td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch05s03.xhtml">Siguiente</a></td></tr></table><hr/></div></header><section class="section" id="idp437184"><div class="titlepage"><div><div><h2 class="title" style="clear: both">RabbitMQ</h2></div></div></div><p>
      RabbitMQ es una plataforma de mensajería para aplicaciones, fácil de usar, que funciona en la mayoría de los sistemas operativos, de código abierto y con multitud de wrappers para diferentes lenguajes de programación, como Node.JS, C++, Java, Python…
    </p><p>
      Una plataforma de mensajería permite a las aplicaciones conectarse y escalar de forma sencilla y rápida. Las aplicaciones pueden conectarse con otras aplicaciones, o bien diferentes componentes pueden ser independientes y constituir entre todos una gran aplicación o incluso poder enviar o recibir datos. La mensajería es asíncrona, por lo que se desacoplan las aplicaciones y se basa en eventos (de recepción, de envío).
    </p><p>
      Algunas de las grandes características de RabbitMQ son:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="formalpara-title">Confiabilidad. </span>
            RabbitMQ tiene una serie de funcionalidades que hacen que la entrega de los mensajes pueda ser confiable, mediante la persistencia de mensajes (el mensaje no se guarda sólo en RAM, sino también en disco, recuperable en caso de que haya un error en el sistema), aceptaciones de entrega (puede ser automático o manual, por ejemplo, se quiere decir que un mensaje está recibido cuando se ha procesado correctamente), confirmación de publicación (si ha habido fallos al enviar mensajes a las colas) y alta escalabilidad.
          </p></li><li class="listitem"><p><span class="formalpara-title">Enrutado flexible. </span>
            Los mensajes son enrutados a través de intercambios antes de llegar a las colas, y RabbitMQ provee varias técnicas de enrutado, como hacer round-robin, el típico publicador-suscriptor o incluso se pueden mezclar técnicas simples con complejas para poder realizar cualquier enrutado imaginable.
          </p></li><li class="listitem"><p><span class="formalpara-title">Clustering. </span>
            Se pueden conectar varias instancias de RabbitMQ en una red local, haciendo un único y simple servidor.
          </p></li><li class="listitem"><p><span class="formalpara-title">Federación. </span>
            Es similar al modo cluster pero con mayor tolerancia a fallos, usando redes que son más propensas a fallos, como en una red WAN, por ejemplo, teniendo las instancias en diferentes centros de datos distribuidos por el mundo.
          </p></li><li class="listitem"><p><span class="formalpara-title">Colas con alta disponibilidad. </span>
            Las colas pueden crearse en modo espejo en varias máquinas en un mismo cluster, por lo que si una máquina falla, la cola estará replicada en otra, y el fallo será transparente para los programas que usen este sistema de mensajería. Además, se comprobará automáticamente y se intentará unir de nuevo los nodos caídos.
          </p></li><li class="listitem"><p><span class="formalpara-title">Clientes múltiples. </span>
            Como se ha comentado anteriormente, RabbitMQ ofrece muchos clientes para lenguajes de programación populares, ya sea para desarrollos de backend, como C++, Node.js, Python, Ruby o incluso Erlang, como para clientes frontend, como JavaScript en el navegador.
          </p></li></ul></div><section class="section" id="idp618080"><div class="titlepage"><div><div><h3 class="title">Cometido principal</h3></div></div></div><p>
        El uso principal en el servidor de notificaciones es la de pasar mensajes entre los diferentes actores que están en ejecución, de forma desacoplada y funcionando de forma independiente, esperando a eventos que desencadenen una reacción dependiendo de qué contengan y qué haya que realizar según el mensaje.
      </p><p>
        El uso más simple que se da es el de algunas instancias creando contenido, que son los que publican y envían los mensajes a las colas, y otros que son los consumidores, los que reciben los mensajes y realizan con ellos diferentes tareas. De este modo, los suscriptores están apuntados a determinadas colas o tópicos, esperando que lleguen mensajes que alguien mete por el otro extremo. Es el caso de la cola <code class="code">newMessages</code>, la cual es escrita por el servidor que provee la interfaz a los servidores de terceros, llamado Applicacion Server (<code class="code">AS</code>), metiendo, bien los mensajes completos (cuando su tiempo de vida sea 0), o bien el identificador que él ha creado y ha guardado en la base de datos, para que el consumidor lo lea y entienda que tiene que entregar los mensajes dependiendo de algunos parámetros que se pasan en dicho mensaje en la cola.
      </p></section><section class="section" id="idp621744"><div class="titlepage"><div><div><h3 class="title">Comparativa frente a otras soluciones</h3></div></div></div><p>
        En un primer momento el software de mensajería utilizado era ActiveMQ<a href="#ftn.idp622800" class="footnote"><sup class="footnote" id="idp622800">[22]</sup></a> ya que en el plan tecnológico se prefería el uso de esta tecnología, sin especificar las razones.
      </p><p>
        Sin embargo, teniendo en cuenta el uso que se estaba dando en el servidor de notificaciones, en el que no se requería que hubiera una persistencia de datos, uno de los puntos flojos de ActiveMQ, se empezó a usar el protocolo STOMP<a href="#ftn.idp624112" class="footnote"><sup class="footnote" id="idp624112">[23]</sup></a>, el predeterminado de ActiveMQ.
      </p><p>
        El problema surgió cuando hubo que probar el despliegue, añadiendo pruebas de alta disponibilidad, tolerancia a fallos y durabilidad en el tiempo, momento en el que se descartó ActiveMQ debido a que era muy débil en cuanto alguno de sus nodos fallaran. Entonces dado que el cluster era solamente maestro-esclavo, hacía que la escalabilidad fuera muy mala.
      </p><p>
        A partir de ese momento se buscaron otras soluciones de mensajería, viendo Apollo<a href="#ftn.idp625984" class="footnote"><sup class="footnote" id="idp625984">[24]</sup></a>, que es una nueva implementación de ActiveMQ basada en eventos y mucho más eficaz que su hermano mayor, ZeroMQ<a href="#ftn.idp626672" class="footnote"><sup class="footnote" id="idp626672">[25]</sup></a>, descartada por su gran curva de aprendizaje y su API a muy bajo nivel. Al final se decidió que RabbitMQ, con el que se hicieron más pruebas de carga, fuera la fundación final para los problemas de mensajería que se habían presentado, obligando a cambiar el protocolo de intercambio de datos, de STOMP a AMQP<a href="#ftn.idp627536" class="footnote"><sup class="footnote" id="idp627536">[26]</sup></a>, nativo de RabbitMQ y estandarizado e implementado por la mayoría de los sistemas de colas (por lo que en un futuro se podría cambiar el software de mensajería sin que diera problemas el servidor de notificaciones).
      </p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h3 class="title">Nota</h3><p>Hay que destacar que debido a los problemas que se encontraron en ActiveMQ, el plan tecnológico está siendo revisado y es muy probable que en un futuro cercano se prefiera la opción de RabbitMQ en vez de ActiveMQ.</p></div></section><div class="footnotes"><br/><hr class="footnote-hr"/><div id="ftn.idp622800" class="footnote"><p><a href="#idp622800" class="para"><sup class="para">[22] </sup></a>http://activemq.apache.org/</p></div><div id="ftn.idp624112" class="footnote"><p><a href="#idp624112" class="para"><sup class="para">[23] </sup></a>http://stomp.github.com/</p></div><div id="ftn.idp625984" class="footnote"><p><a href="#idp625984" class="para"><sup class="para">[24] </sup></a>http://activemq.apache.org/apollo/</p></div><div id="ftn.idp626672" class="footnote"><p><a href="#idp626672" class="para"><sup class="para">[25] </sup></a>http://www.zeromq.org/</p></div><div id="ftn.idp627536" class="footnote"><p><a href="#idp627536" class="para"><sup class="para">[26] </sup></a>http://www.amqp.org/</p></div></div></section><footer><div class="navfooter"><hr/><table style="width: 100%; "><tr><td style="width: 40%; text-align: left; "><a accesskey="p" href="ch05.xhtml">Anterior</a> </td><td style="width: 20%; text-align: center; "><a accesskey="u" href="ch05.xhtml">Subir</a></td><td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch05s03.xhtml">Siguiente</a></td></tr><tr><td style="width: 40%; text-align: left; vertical-align: top; ">Capítulo 5. Tecnologías </td><td style="width: 20%; text-align: center; "><a accesskey="h" href="index.xhtml">Inicio</a></td><td style="width: 40%; text-align: right; vertical-align: top; "> MongoDB</td></tr></table></div></footer></body></html>
