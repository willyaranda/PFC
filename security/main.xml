<?xml version="1.0" encoding="utf-8"?>
<chapter xml:id="security"
      xmlns="http://docbook.org/ns/docbook"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      version="5.0" xml:lang="es">

  <title>Seguridad</title>
  <para>
    La seguridad es uno de los puntos más importantes en cualquier sistema informático, y por supuesto no ha podido obviarse en este proyecto. Tener un sistema seguro es una tarea complicada, que requiere de mucho esfuerzo y dedicación, y sobre todo, de investigar cuáles pueden ser los fallos del sistema que pueden ser abusados. Aún así, cualquier sistema, por muy seguro que sea, siempre puede ser mejorado, y debe serlo, puesto que en el servidor de notificaciones estamos moviendo mensajes, que pueden ir en claro, e identificando quién los manda y hacia qué terminales, por lo que puede ser un grave problema si tenemos algún fallo de seguridad.
  </para>
  <para>
    Así pues, ha habido diferentes elementos del sistema que ha habido que poner más énfasis en la seguridad, bien porque eran susceptibles de mostrar información personal, bien porque se creía que podrían recibir ataques por fuerza bruta o de denegación de servicio o incluso porque son aquellos que están expuestos tanto a los terminales como a Internet, y siempre son un dulce muy apetitoso para personas con no buenas intenciones.
  </para>
  <section>
    <title>Tokens de dispositivo</title>
    <para>
      El primer punto de entrada al sistema de notificaciones push es tener un token de dispositivo válido que permitirá que el UA (User Agent, explicado en el capítulo "API") se registre de forma correcta en el sistema.
    </para>
    <para>
      Entonces, había que garantizar de algún modo que este token fuera tanto único como válido en nuestro sistema para poder controlar el abuso, y si los registros de dispositivos venían de donde nosotros queríamos, esto es: de dispositivos con Firefox OS en un primer lugar.
    </para>
    <para>
      A lo largo del tiempo, se han desarrollado muchos mecanismos de intercambio de información para realizar conexiones de usuario de forma controlada, o identificación de aplicaciones sin tener que dar los nombres de usuario y contraseñas a servicios de terceros, como OAuth<footnote><para>http://oauth.net/2/</para></footnote>. Sin embargo, en caso de la primera versión del servidor de notificaiones, se quería algo más sencillo, lo que se tradujo en los siguientes preceptos:
    </para>
    <itemizedlist>
      <listitem>
        <formalpara>
          <title>Verificación sencilla</title>
          <para>
            No debería requerir el uso de mucho cómputo para comprobar si el token de usuario es válido o no.
          </para>
        </formalpara>
      </listitem>
      <listitem>
        <formalpara>
          <title>Rápido de generar</title>
          <para>
            Generación al vuelo, por lo que tendría que hacerse de forma rápida, ya que el cálculo era la respuesta a una petición HTTP y no se podía dejar dicha conexión HTTP abierta, por el uso de recursos en el sistema.
          </para>
        </formalpara>
        <formalpara>
          <title>Posibilidad de cambiarse en un futuro</title>
          <para>
            Si se decide a usar un nuevo sistema en el futuro, como pudiera ser OAuth, Mozilla Persona<footnote><para>https://support.mozilla.org/es/kb/que-es-y-como-funciona-browserid . Mozilla Persona es un sistema de identificación similar a OpenID, con la diferencia de que Persona usa direcciones de correo en vez de URLs, lo que resulta más natural para la identificación</para></footnote> (con lo que encajaría más aún en el sistema Firefox OS) o incluso que el token viniera preconfigurado desde fábrica no debería suponer un cambio drástico en la infraestructura.
          </para>
        </formalpara>
      </listitem>
    </itemizedlist>
    <para>
      Así pues, la decisión en la implementación de generar un token<footnote><para>Se puede ver el módulo que realiza esta generación y verificación en: https://github.com/telefonicaid/notification_server/blob/develop/src/common/token.js</para></footnote>, se quedó con el siguiente código:
    </para>
    <figure>
      <title>Generación de token</title>
        <programlisting language="JavaScript" linenumbering="numbered" width="120">
<![CDATA[function token() {}

token.prototype = {
  serialNumber: 1,

  // The TOKEN shall be unique
  get: function() {
    // SerialNumber + TimeStamp + NotificationServer_Id + CRC -> RAWToken
    var rawToken = this.serialNumber++ + "#" + Date.now() + "#" +
                   process.serverId + "_" + uuid.v1();

    // CRC
    rawToken += "@" + crypto.hashMD5(rawToken);

    // Encrypt token with AES
    return crypto.encryptAES(rawToken, cryptokey);
  },
};
]]>
      </programlisting>
    </figure>
    <para>
      Así, en la figura anterior, podemos ver cómo está generado el token de dispositivo:
    </para>
    <orderedlist>
      <listitem>
        <para>
          Usamos un número de serie que aumenta en una unidad cada vez que hay una nueva petición.
        </para>
      </listitem>
      <listitem>
        <para>
          Añadimos el momento de generación actual, en milisegundos (según el estándar de JavaScript).
        </para>
      </listitem>
      <listitem>
        <para>
          Añadimos el PID del proceso que lo ha generado.
        </para>
      </listitem>
      <listitem>
        <para>
          Y un UUID (versión 1) para añadir aleatoriedad
        </para>
      </listitem>
      <listitem>
        <para>
          Calculamos el hash MD5 del <code>rawToken</code> inicial, que se lo añadimos al token inicial con un <code>@</code> entre medias. Esto lo usamos como CRC.
        </para>
      </listitem>
      <listitem>
        <para>
          Devolvemos el token generado cifrado con AES y la clave <code>cryptoKey</code> que está configurada en el fichero <filename>config.js</filename> que deben obligatoriamente compartir todos las instancias del servidor de notificaciones que generen tokens, pues es el principal medio para descifrar el token para realizar las operaciones y se usa para comprobar si es válido en el sistema.
        </para>
      </listitem>
    </orderedlist>
    <para>
      Así pues, se puede observar que el token puede ser comprobado mediante la verificación con la función <code>verify(token)</code>, esto es, descifrando el token y comprobando su CRC. En primer lugar, si el descifrado no es correcto, el token recibido no es válido, por lo que podemos rechazarlo. Pero además, y en segundo lugar, podemos comprobar si el CRC, esto es, separando por el caracter <code>@</code> que habrá después de descifrar y comprobando si la segunda parte (el llamado CRC, o hash MD5) concuerda con la primera parte, habiéndole aplicado la función de hash.
      <figure>
        <title>Verificación de tokens</title>
        <programlisting language="JavaScript">
<![CDATA[// Verify the given TOKEN
verify: function(token) {
  if(!token)
    return false;

  // Decrypt token
  var rawToken = crypto.decryptAES(token, cryptokey).split('@');

  // CRC Verification
  return (rawToken[1] == crypto.hashMD5(rawToken[0]));
}
]]>
        </programlisting>
      </figure>
    </para>
  </section>

  <section>
    <title>Registro con clave pública-privada</title>
    <para>
      Todas las aplicaciones que quieran recibir notificaciones tienen que registrarse con una clave pública, que es la encargada de la verificación de las firmas de cada notificación. Esto se realiza desde la propia aplicación web, con el API que hay entre la WA y el UA, mediante la función:
      <figure>
        <title>Registro de WA en el UA</title>
        <programlisting language="javascript">
<![CDATA[DOMRequest navigator.mozPush.requestURL(DOMString watoken, DOMString pbk)]]>
        </programlisting>
      </figure>
    </para>
    <para>
      Así pues, es obligatorio que haya un par de claves públicas-privadas (soportando sólo <code>RSA-SHA256</code> en la primera versión) para poder registrarse y posteriormente enviar y recibir correctamente notificaciones.
    </para>
    <para>

    </para>
  </section>

  <section>
    <title>Notificaciones firmadas</title>
    <para>
      Como se ha comentado en la sección anterior, es obligatorio que se registren las aplicaciones con una clave pública-privada con <code>RSA-SHA256</code>. Esto no se hace sólo por añadir un nivel más de seguridad, si no por proteger a los dispositivos que están dentro de la red móvil. Así, esta idea se ha desarrollado para permitir notificaciones sólo desde lugares a los que se haya permitido mandar notificaciones, esto es, aquellos registrados con una clave pública que puede verificar la firma de la notificación enviada con la clave privada.
    </para>
    <para>
      El funcionamiento es el mismo que el sistema PGP con el correo cifrado o firmado, ya que del contenido se crea una firma con la llave privada (que sólo la tendrá el servidor que envía la notificación), que se manda al servidor de notificaciones (a una URL determinada, que es capaz de saber la clave pública que verifica dicha firma) y comprueba si es correcta o no. Si lo es, deja pasar la notificación al sistema y, eventualmente, se entregará. Si no es válida, por la razón que sea, la notificación es rechazada y ni siquiera entra al sistema.
    </para>
    <para>
      Pero, ¿qué se consigue con esto? En primer lugar mantener acotados los servicios que pueden mandar notificaciones. Un desarrollador tiene control sobre la llave pública, puesto que es la que concuerda con su llave privada. Si pierde la llave privada, no podrá hacer nada, por lo que no podrá volver a mandar notificaciones. Pero además, si pierde esa llave pero la recoge una persona malintencionada y decide empezar a mandar notificaciones causando una riada de mensajes, puede rápidamente actualizar su aplicación, configurar su nueva clave pública y privada, y todos los dispositivos con esta nueva instalación se registrarán de nuevo (los dispositivos comprueban entre actualizaciones de la aplicación si la llave pública de la aplicación ha cambiado, y si es así, se registran de nuevo) por lo que no recibirán mensajes desde la llave robada, si no desde la nueva, ya que el sistema ni las dejará pasar.
    </para>
    <para>
      Y en segundo lugar, se puede verificar el origen e internamente hacer un control de abuso llegado el caso. Por ejemplo, si un servicio no hace más que enviar mensajes de broadcast hacia el interior, se puede revocar todas los registros de aplicaciones que tienen dicha clave y se protegerá de forma fácil al usuario, y por supuesto al desarrollador.
    </para>
  </section>

  <section>
    <title>Verificación de notificaciones</title>
    <para>
      …
    </para>
  </section>

  <section>
    <title>Ataque DDoS: flooding</title>
    <para>
      …
    </para>
  </section>

  <section>
    <title>Comunicación cifrada vía SSL</title>
    <para>
      …
    </para>
  </section>

</chapter>
