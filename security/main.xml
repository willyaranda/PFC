<?xml version="1.0" encoding="utf-8"?>
<chapter xml:id="security"
      xmlns="http://docbook.org/ns/docbook"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      version="5.0" xml:lang="es">

  <title>Seguridad</title>
  <para>
    La seguridad es uno de los puntos más importantes en cualquier sistema informático, y por supuesto no ha podido obviarse en este proyecto. Tener un sistema seguro es una tarea complicada, que requiere de mucho esfuerzo y dedicación, y sobre todo, de investigar cuáles pueden ser los fallos del sistema que pueden ser abusados. Aún así, cualquier sistema, por muy seguro que sea, siempre puede ser mejorado, y debe serlo, puesto que en el servidor de notificaciones estamos moviendo mensajes, que pueden ir en claro, e identificando quién los manda y hacia qué terminales, por lo que puede ser un grave problema si tenemos algún fallo de seguridad.
  </para>
  <para>
    Así pues, ha habido diferentes elementos del sistema que ha habido que poner más énfasis en la seguridad, bien porque eran susceptibles de mostrar información personal, bien porque se creía que podrían recibir ataques por fuerza bruta o de denegación de servicio o incluso porque son aquellos que están expuestos tanto a los terminales como a Internet, y siempre son un dulce muy apetitoso para personas con no buenas intenciones.
  </para>
  <section>
    <title>Tokens de dispositivo</title>
    <para>
      El primer punto de entrada al sistema de notificaciones push es tener un token de dispositivo válido que permitirá que el UA (User Agent, explicado en el capítulo "API") se registre de forma correcta en el sistema.
    </para>
    <para>
      Entonces, había que garantizar de algún modo que este token fuera tanto único como válido en nuestro sistema para poder controlar el abuso, y si los registros de dispositivos venían de donde nosotros queríamos, esto es: de dispositivos con Firefox OS en un primer lugar.
    </para>
    <para>
      A lo largo del tiempo, se han desarrollado muchos mecanismos de intercambio de información para realizar conexiones de usuario de forma controlada, o identificación de aplicaciones sin tener que dar los nombres de usuario y contraseñas a servicios de terceros, como OAuth<footnote><para>http://oauth.net/2/</para></footnote>. Sin embargo, en caso de la primera versión del servidor de notificaiones, se quería algo más sencillo, lo que se tradujo en los siguientes preceptos:
    </para>
    <itemizedlist>
      <listitem>
        <formalpara>
          <title>Verificación sencilla</title>
          <para>
            No debería requerir el uso de mucho cómputo para comprobar si el token de usuario es válido o no.
          </para>
        </formalpara>
      </listitem>
      <listitem>
        <formalpara>
          <title>Rápido de generar</title>
          <para>
            Generación al vuelo, por lo que tendría que hacerse de forma rápida, ya que el cálculo era la respuesta a una petición HTTP y no se podía dejar dicha conexión HTTP abierta, por el uso de recursos en el sistema.
          </para>
        </formalpara>
        <formalpara>
          <title>Posibilidad de cambiarse en un futuro</title>
          <para>
            Si se decide a usar un nuevo sistema en el futuro, como pudiera ser OAuth, Mozilla Persona<footnote><para>https://support.mozilla.org/es/kb/que-es-y-como-funciona-browserid . Mozilla Persona es un sistema de identificación similar a OpenID, con la diferencia de que Persona usa direcciones de correo en vez de URLs, lo que resulta más natural para la identificación</para></footnote> (con lo que encajaría más aún en el sistema Firefox OS) o incluso que el token viniera preconfigurado desde fábrica no debería suponer un cambio drástico en la infraestructura.
          </para>
        </formalpara>
      </listitem>
    </itemizedlist>
    <para>
      Así pues, la decisión en la implementación de generar un token<footnote><para>Se puede ver el módulo que realiza esta generación y verificación en: https://github.com/telefonicaid/notification_server/blob/develop/src/common/token.js</para></footnote>, se quedó con el siguiente código:
    </para>
    <figure>
      <title>Generación de token</title>
        <programlisting language="JavaScript" linenumbering="numbered" width="120">
<![CDATA[function token() {}

token.prototype = {
  serialNumber: 1,

  // The TOKEN shall be unique
  get: function() {
    // SerialNumber + TimeStamp + NotificationServer_Id + CRC -> RAWToken
    var rawToken = this.serialNumber++ + "#" + Date.now() + "#" +
                   process.serverId + "_" + uuid.v1();

    // CRC
    rawToken += "@" + crypto.hashMD5(rawToken);

    // Encrypt token with AES
    return crypto.encryptAES(rawToken, cryptokey);
  },
};
]]>
      </programlisting>
    </figure>
    <para>
      Así, en la figura anterior, podemos ver cómo está generado el token de dispositivo:
    </para>
    <orderedlist>
      <listitem>
        <para>
          Usamos un número de serie que aumenta en una unidad cada vez que hay una nueva petición.
        </para>
      </listitem>
      <listitem>
        <para>
          Añadimos el momento de generación actual, en milisegundos (según el estándar de JavaScript).
        </para>
      </listitem>
      <listitem>
        <para>
          Añadimos el PID del proceso que lo ha generado.
        </para>
      </listitem>
      <listitem>
        <para>
          Y un UUID (versión 1) para añadir aleatoriedad
        </para>
      </listitem>
      <listitem>
        <para>
          Calculamos el hash MD5 del <code>rawToken</code> inicial, que se lo añadimos al token inicial con un <code>@</code> entre medias. Esto lo usamos como CRC.
        </para>
      </listitem>
      <listitem>
        <para>
          Devolvemos el token generado cifrado con AES y la clave <code>cryptoKey</code> que está configurada en el fichero <filename>config.js</filename> que deben obligatoriamente compartir todos las instancias del servidor de notificaciones que generen tokens, pues es el principal medio para descifrar el token para realizar las operaciones y se usa para comprobar si es válido en el sistema.
        </para>
      </listitem>
    </orderedlist>
    <para>
      Así pues, se puede observar que el token puede ser comprobado mediante la verificación con la función <code>verify(token)</code>, esto es, descifrando el token y comprobando su CRC. En primer lugar, si el descifrado no es correcto, el token recibido no es válido, por lo que podemos rechazarlo. Pero además, y en segundo lugar, podemos comprobar si el CRC (el hash MD5 calculado en la figura anterior) es válido, separando por el caracter <code>@</code> que habrá después de descifrar y comprobando si la segunda parte concuerda con la primera parte, habiéndole aplicado la misma función de hash.
      <figure>
        <title>Verificación de tokens</title>
        <programlisting language="JavaScript">
<![CDATA[// Verify the given TOKEN
verify: function(token) {
  if(!token)
    return false;

  // Decrypt token
  var rawToken = crypto.decryptAES(token, cryptokey).split('@');

  // CRC Verification
  return (rawToken[1] == crypto.hashMD5(rawToken[0]));
}
]]>
        </programlisting>
      </figure>
    </para>
  </section>

  <section>
    <title>Registro con clave pública-privada</title>
    <para>
      Todas las aplicaciones que quieran recibir notificaciones tienen que registrarse con dos parámetros: el primero es un identificador único y el segundo una clave pública codificada en base64<footnote><para>RFC4648, página 5, punto 4, "Base 64 Encoding": http://tools.ietf.org/html/rfc4648#page-5</para></footnote>, que es la encargada de la verificación de las firmas de cada notificación. Esto se realiza desde la propia aplicación web, con el API que hay entre la WA y el UA, mediante la función:
      <figure>
        <title>Registro de WA en el UA</title>
        <programlisting language="javascript">
<![CDATA[DOMRequest navigator.mozPush.requestURL(DOMString watoken, DOMString pbk)]]>
        </programlisting>
      </figure>
    </para>
    <para>
      Así pues, es obligatorio que haya un par de claves públicas-privadas (soportando sólo <code>RSA-SHA256</code> en la primera versión) para poder registrarse y posteriormente enviar y recibir correctamente notificaciones.
    </para>
  </section>

  <section>
    <title>Notificaciones firmadas</title>
    <para>
      Como se ha comentado en la sección anterior, en el registro es obligatorio contar con una clave pública-privada basada en <code>RSA-SHA256</code>. Esto no se hace simplemente por añadir un atributo más al registro, si no por proteger a los dispositivos que están dentro de la red móvil. Así, esta idea se ha implementado para permitir notificaciones sólo desde lugares a los que se haya aceptado mandar notificaciones, esto es, aquellos registrados con una clave pública que puede verificar la firma de la notificación enviada con la clave privada que sólo tendrán los servidores de la aplicación (servidor <code>AS</code>).
    </para>
    <para>
      El funcionamiento es el mismo que el sistema PGP con el correo firmado, ya que del contenido (atributo <code>message</code> de la notificación <code>JSON</code> enviada por <code>POST</code>) se crea una firma con la llave privada (que sólo la tendrá el servidor que envía la notificación, o <code>AS</code>), que se manda al servidor de notificaciones (a una URL determinada, que es capaz de saber la clave pública que verifica dicha firma) y comprueba si es correcta o no. Si lo es, deja pasar la notificación al sistema y, eventualmente, se entregará. Si no es válida, por la razón que sea, la notificación es rechazada y ni siquiera entra al sistema.
    </para>
    <figure>
      <title>Verificación de firma (en <filename>src/common/crypto.js</filename>)</title>
      <programlisting language="JavaScript">
<![CDATA[
verifySignature: function(data, signature, publicKey) {
  var algorithm = 'RSA-SHA256';
  var verifier = crypto.createVerify(algorithm);
  verifier.update(data);
  return verifier.verify(publicKey, signature, 'hex');
},
]]>
      </programlisting>
    </figure>
    <figure>
      <title>Comprobación de firma (en <filename>src/ns_as/ns_as_server.js</filename>)</title>
      <programlisting language="JavaScript">
<![CDATA[
//Get the PbK for the apptoken in the database
dataStore.getPbkApplication(apptoken, function(error, pbkbase64) {
  if (error) {
    return callback(errorcodesAS.BAD_MESSAGE_BAD_SIGNATURE);
  }
  var pbk = new Buffer(pbkbase64 || '', 'base64').toString('ascii');
  if (!crypto.verifySignature(normalizedNotification.message,
                              json.signature, pbk)) {
    log.debug('NS_AS::onNewPushMessage --> Rejected. Bad signature');
    return callback(errorcodesAS.BAD_MESSAGE_BAD_SIGNATURE);
  }
  ...
  // La firma es válida, continuar el flujo normal
  ...
]]>
      </programlisting>
    </figure>
    <para>
      Pero, ¿qué se consigue con esto? En primer lugar mantener acotados los servicios que pueden mandar notificaciones puesto que un desarrollador tiene control sobre la llave pública, puesto que es la que concuerda con su llave privada. Si pierde la llave privada, no podrá hacer nada, por lo que no podrá volver a mandar notificaciones. Pero además, si la recoge una persona malintencionada y decide empezar a mandar notificaciones causando una riada de mensajes, puede rápidamente actualizar su aplicación, poniendo su nueva clave pública en sus ficheros de configuración y la privada en sus servidores, y todos los dispositivos con esta nueva instalación se registrarán de nuevo (los dispositivos comprueban entre actualizaciones de la aplicación si la llave pública de la aplicación ha cambiado, y si es así, se registran de nuevo) por lo que no recibirán mensajes desde la llave robada, si no desde la nueva, ya que el sistema ni las dejará pasar.
    </para>
    <para>
      Y en segundo lugar, se puede hacer un control de abuso llegado el caso. Por ejemplo, si un servicio no hace más que enviar mensajes de broadcast hacia el interior, se puede revocar todas los registros de aplicaciones que tienen dicha clave y se protegerá de forma fácil al usuario.
    </para>
  </section>

  <section>
    <title>Verificación de notificaciones</title>
    <para>
      En cuanto llega una notificación, o dicho de otra manera, cualquier mensaje mediante una petición <code>POST</code> a la interfaz que expone el servidor de notificaciones hacia el exterior (en este caso se habla del <code>API</code> hacia el Application Server o <code>AS</code>), hay que comprobar una serie de criterios para verificar que la notificación es correcta.
    </para>
    <para>
      En primer lugar, se comprueba que el mensaje enviado es un mensaje <code>JSON</code> bien formado, con la función <code>JSON.parse(notification)</code> nativa de JavaScript. Si es así, se pasa a comprobar el resto de campos, de la forma:
    </para>
    <para>
      <itemizedlist>
        <listitem>
          <para>
            Que el atributo <code>messageType</code> de la notificación es igual a la cadena <code>notification</code>.
          </para>
        </listitem>
        <listitem>
          <para>
            Que esté correctamente firmado, como se explica en la sección anterior.
          </para>
        </listitem>
      <listitem>
          <para>
            Que tenga un identificador externo, esto es, que el atributo <code>id</code> no puede estar sin definir (<code>undefined</code> al parsear el <code>JSON</code>) o ser nulo, puesto que en un futuro se podría agregar la opción de sobreescribir notificaciones y poder preguntar por el estado de la entrega de una notificación a través de este identificador único para el servicio de terceros o <code>AS</code>.
          </para>
        </listitem>
        <listitem>
          <para>
            Que el atributo <code>message</code> e <code>id</code> no superen los 4KiB. Esto es debido a que la longitud máxima que se peryo smite en el servidor es de 4KiB. Probablemente en el futuro se cambie la restricción de tamaño para la parte de <code>id</code> y se obligue a un tamaño más pequeño, ya que 4096 bytes de identificación suficiente para cualquier aplicación.
          </para>
        </listitem>
      </itemizedlist>
      holas
    </para>
  </section>

  <section>
    <title>Ataque DDoS: flooding</title>
    <para>
      …
    </para>
  </section>

  <section>
    <title>Comunicación cifrada vía SSL</title>
    <para>
      …
    </para>
  </section>

</chapter>
