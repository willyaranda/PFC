<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Capítulo 7. Lecciones aprendidas</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="prev" href="ch06s08.xhtml" title="Entrega de notificaciones a las aplicaciones"/><link rel="next" href="ch07s02.xhtml" title="Investigar nuevas tecnologías"/></head><body><header><div class="navheader"><table style="width: 100%; "><tr><th style="text-align: center; " colspan="3">Capítulo 7. Lecciones aprendidas</th></tr><tr><td style="width: 20%; text-align: left; "><a accesskey="p" href="ch06s08.xhtml">Anterior</a> </td><th style="width: 60%; text-align: center; "> </th><td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch07s02.xhtml">Siguiente</a></td></tr></table><hr/></div></header><section xml:lang="es" class="chapter" id="lessons_learned"><div class="titlepage"><div><div><h1 class="title">Capítulo 7. Lecciones aprendidas</h1></div></div></div><div class="toc"><div class="toc-title">Tabla de contenidos</div><ul><li><span class="section"><a href="ch07.xhtml#idp755632">SQL contra NoSQL</a></span></li><li><span class="section"><a href="ch07s02.xhtml">Investigar nuevas tecnologías</a></span></li><li><span class="section"><a href="ch07s03.xhtml">Tener tests unitarios y funcionales</a></span></li><li><span class="section"><a href="ch07s04.xhtml">Priorización y enfoque en tareas</a></span></li><li><span class="section"><a href="ch07s05.xhtml">Trabajar en abierto</a></span></li><li><span class="section"><a href="ch07s06.xhtml">La importancia del hardware</a></span></li></ul></div><p>
    Durante el concepto inicial, desarrollo e implementación del servidor de push, se encontraron muchas variables que han hecho cambiar ligeramente el rumbo tomado por el proyecto. Sin embargo, la idea general seguía presente y los cambios que se fueron realizando eran debidos a cosas que se creía que eran más interesantes de tener, como mensajes de deregistro, posibilidad de encolar mensajes y mandar sólo un mensaje final, añadir <code class="code">ACK</code>s específicos de aplicación y no usar los propios de TCP…
  </p><section class="section" id="idp755632"><div class="titlepage"><div><div><h2 class="title" style="clear: both">SQL contra NoSQL</h2></div></div></div><p>
      Una de las primeras decisiones tomadas en el proyecto fue la de usar una base de datos no relacional, también llamadas No-SQL. En este caso se eligió MongoDB debido a que era la seleccionada por el plan tecnológico de la empresa. La decisión entre elegir una base de datos No-SQL frente a una SQL convencional (como puede ser MySQL u Oracle) fue simplemente la de no tener un esquema estricto para cada uno de los datos que se iban a introducir, ya que se creía que el esquema cambiaría en el futuro según se fuera iterando (y así sucedió de hecho), y permitiría un prototipado de la plataforma mucho más rápido.
    </p><p>
      Sin embargo, el cambiar radicamente la mentalidad entre una solución SQL a algo No-SQL, muy relajado y sin un esquema fijo para todos los "elementos" de una misma "tabla" podría suponer un peligro, puesto que las nociones de SQL y muchas de las decisiones para estos sistemas se toman a partir de dichos conocimientos.
    </p><p>
      Así pues una de las primeras cosas fue "dejar de pensar de forma relacional", con todo lo que ello implica, como la pérdida de alguna de las propiedades ACID<a href="#ftn.idp758448" class="footnote"><sup class="footnote" id="idp758448">[34]</sup></a>. E incluso la noción de tabla y de esquema.
    </p><p>
      Mientras que en las bases de datos SQL hay un montón de restricciones, los esquemas son muy fijos y hay que respetar todas las normas ACID, además de intentar normalizar la base de datos para poder cumplir las cuatro normas básicas, en NoSQL depende mucho de cuál sea la base de datos seleccionada el qué hacer, básicamente porque cada una tiene sus características y rompen las propiedades ACID de diferentes maneras.
    </p><p>
      Así pues, algunas de las características de la base de datos elegida, MongoDB, hacen que las consultas sean mucho más rápidas cuando esté todo en el mismo sitio, lo que quiere decir que es mejor duplicar datos a hacer varias consultas a la vez. De hecho, si hay que hacer varias consultas, es mejor que no sean complejas, y que se encargan los diferentes backend de unir los datos, ya que así liberamos de tareas pesadas a los mismos gestores. Por ejemplo, hacer un <code class="code">JOIN</code> en MongoDB es muy pesado, pero sin embargo es muy rápido si se hacen dos consultas por separado y las unimos en el código del programa.
    </p></section><div class="footnotes"><br/><hr class="footnote-hr"/><div id="ftn.idp758448" class="footnote"><p><a href="#idp758448" class="para"><sup class="para">[34] </sup></a><abbr class="acronym">ACID</abbr>: Atomicity, Consistency, Isolation y Durability</p></div></div></section><footer><div class="navfooter"><hr/><table style="width: 100%; "><tr><td style="width: 40%; text-align: left; "><a accesskey="p" href="ch06s08.xhtml">Anterior</a> </td><td style="width: 20%; text-align: center; "> </td><td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch07s02.xhtml">Siguiente</a></td></tr><tr><td style="width: 40%; text-align: left; vertical-align: top; ">Entrega de notificaciones a las aplicaciones </td><td style="width: 20%; text-align: center; "><a accesskey="h" href="index.xhtml">Inicio</a></td><td style="width: 40%; text-align: right; vertical-align: top; "> Investigar nuevas tecnologías</td></tr></table></div></footer></body></html>
