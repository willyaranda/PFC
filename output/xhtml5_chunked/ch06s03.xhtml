<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Notificaciones firmadas</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="prev" href="ch06s02.xhtml" title="Registro con clave pública-privada"/><link rel="next" href="ch06s04.xhtml" title="Verificación de notificaciones"/></head><body><header><div class="navheader"><table style="width: 100%; "><tr><th style="text-align: center; " colspan="3">Notificaciones firmadas</th></tr><tr><td style="width: 20%; text-align: left; "><a accesskey="p" href="ch06s02.xhtml">Anterior</a> </td><th style="width: 60%; text-align: center; ">Capítulo 6. Seguridad</th><td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch06s04.xhtml">Siguiente</a></td></tr></table><hr/></div></header><section class="section" id="idp532512"><div class="titlepage"><div><div><h2 class="title" style="clear: both">Notificaciones firmadas</h2></div></div></div><p>
      Como se ha comentado en la sección anterior, en el registro es obligatorio contar con una clave pública-privada basada en <code class="code">RSA-SHA256</code>. Esto no se hace simplemente por añadir un atributo más al registro, si no por proteger a los dispositivos que están dentro de la red móvil. Así, esta idea se ha implementado para permitir notificaciones sólo desde lugares a los que se haya aceptado mandar notificaciones, esto es, aquellos registrados con una clave pública que puede verificar la firma de la notificación enviada con la clave privada que sólo tendrán los servidores de la aplicación (servidor <code class="code">AS</code>).
    </p><p>
      El funcionamiento es el mismo que el sistema PGP con el correo firmado, ya que del contenido (atributo <code class="code">message</code> de la notificación <code class="code">JSON</code> enviada por <code class="code">POST</code>) se crea una firma con la llave privada (que sólo la tendrá el servidor que envía la notificación, o <code class="code">AS</code>), que se manda al servidor de notificaciones (a una URL determinada, que es capaz de saber la clave pública que verifica dicha firma) y comprueba si es correcta o no. Si lo es, deja pasar la notificación al sistema y, eventualmente, se entregará. Si no es válida, por la razón que sea, la notificación es rechazada y ni siquiera entra al sistema.
    </p><div class="figure" id="idp537696"><div class="figure-title">Figura 6.4. Verificación de firma (en <code class="filename">src/common/crypto.js</code>)</div><div class="figure-contents"><pre class="programlisting">
verifySignature: function(data, signature, publicKey) {
  var algorithm = 'RSA-SHA256';
  var verifier = crypto.createVerify(algorithm);
  verifier.update(data);
  return verifier.verify(publicKey, signature, 'hex');
},
      </pre></div></div><br class="figure-break"/><div class="figure" id="idp130304"><div class="figure-title">Figura 6.5. Comprobación de firma (en <code class="filename">src/ns_as/ns_as_server.js</code>)</div><div class="figure-contents"><pre class="programlisting">
//Get the PbK for the apptoken in the database
dataStore.getPbkApplication(apptoken, function(error, pbkbase64) {
  if (error) {
    return callback(errorcodesAS.BAD_MESSAGE_BAD_SIGNATURE);
  }
  var pbk = new Buffer(pbkbase64 || '', 'base64').toString('ascii');
  if (!crypto.verifySignature(normalizedNotification.message,
                              json.signature, pbk)) {
    log.debug('NS_AS::onNewPushMessage --&gt; Rejected. Bad signature');
    return callback(errorcodesAS.BAD_MESSAGE_BAD_SIGNATURE);
  }
  ...
  // La firma es válida, continuar el flujo normal
  ...
      </pre></div></div><br class="figure-break"/><p>
      Pero, ¿qué se consigue con esto? En primer lugar mantener acotados los servicios que pueden mandar notificaciones puesto que un desarrollador tiene control sobre la llave pública, puesto que es la que concuerda con su llave privada. Si pierde la llave privada, no podrá hacer nada, por lo que no podrá volver a mandar notificaciones. Pero además, si la recoge una persona malintencionada y decide empezar a mandar notificaciones causando una riada de mensajes, puede rápidamente actualizar su aplicación, poniendo su nueva clave pública en sus ficheros de configuración y la privada en sus servidores, y todos los dispositivos con esta nueva instalación se registrarán de nuevo (los dispositivos comprueban entre actualizaciones de la aplicación si la llave pública de la aplicación ha cambiado, y si es así, se registran de nuevo) por lo que no recibirán mensajes desde la llave robada, si no desde la nueva, ya que el sistema ni las dejará pasar.
    </p><p>
      Y en segundo lugar, se puede hacer un control de abuso llegado el caso. Por ejemplo, si un servicio no hace más que enviar mensajes de broadcast hacia el interior, se puede revocar todas los registros de aplicaciones que tienen dicha clave y se protegerá de forma fácil al usuario.
    </p></section><footer><div class="navfooter"><hr/><table style="width: 100%; "><tr><td style="width: 40%; text-align: left; "><a accesskey="p" href="ch06s02.xhtml">Anterior</a> </td><td style="width: 20%; text-align: center; "><a accesskey="u" href="ch06.xhtml">Subir</a></td><td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch06s04.xhtml">Siguiente</a></td></tr><tr><td style="width: 40%; text-align: left; vertical-align: top; ">Registro con clave pública-privada </td><td style="width: 20%; text-align: center; "><a accesskey="h" href="index.xhtml">Inicio</a></td><td style="width: 40%; text-align: right; vertical-align: top; "> Verificación de notificaciones</td></tr></table></div></footer></body></html>
