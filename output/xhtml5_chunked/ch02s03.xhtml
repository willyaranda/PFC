<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Internet</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="prev" href="ch02s02.xhtml" title="Operadores"/><link rel="next" href="ch03.xhtml" title="Capítulo 3. API"/></head><body><header><div class="navheader"><table style="width: 100%; "><tr><th style="text-align: center; " colspan="3">Internet</th></tr><tr><td style="width: 20%; text-align: left; "><a accesskey="p" href="ch02s02.xhtml">Anterior</a> </td><th style="width: 60%; text-align: center; ">Capítulo 2. Estado del arte</th><td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch03.xhtml">Siguiente</a></td></tr></table><hr/></div></header><section xml:lang="es" class="section" id="state_art_Internet_main"><div class="titlepage"><div><div><h2 class="title" style="clear: both">Internet</h2></div></div></div><p>
    Una vez vistas las diferentes plataformas push creadas por los organismos de los operadores de telefonía móvil, el siguiente paso es explicar otros mecanismos, caminando hacia tecnologías más modernas creadas por empresas radicadas principalmente en Internet. Estas tecnologías son relativamente guardan importantes similitudes entre ellas, pero difieren en las cuotas, autenticación… Sin embargo, la idea de cómo mantener el canal de comunicación entre los dispositivos y el servidor de notificaciones es muy semejante.
  </p><p>
    A continuación se procede a una breve explicación de cada una de estas tecnologías.
  </p><section xml:lang="es" class="section" id="state_art_Internet_gcm"><div class="titlepage"><div><div><h3 class="title">GCM: Google Could Messaging</h3></div></div></div><p>
    GCM o Google Cloud Messaging<a href="#ftn.idp28752" class="footnote"><sup class="footnote" id="idp28752">[8]</sup></a> es un sistema de notificaciones push creado por la empresa Google para su sistema operativo Android. Su finalidad es la misma que la del resto de sistemas: entregar notificaciones o mensajes que un servicio de terceros (o incluso la misma plataforma de Google) a los usuarios empleando un dispositivo de una manera fácil, ordenada y controlada.
  </p><p>
    Lanzado en julio de 2012, es uno de los sistemas más grandes, puesto que está presente en todos los dispositivos Android que dispongan de una cuenta de Google asociada, prácticamente la mayoría. El número de usuarios de este servicio no es especificado por Google, pero podría ser similar o inferior al número de dispositivos Android en el mercado, que supera los 500 millones<a href="#ftn.idp30464" class="footnote"><sup class="footnote" id="idp30464">[9]</sup></a>.
  </p><div class="blockquote"><table style="border: 0; width: 100%; cellspacing: 0; cellpadding: 0;" class="blockquote"><tr><td style="width: 10%; vertical-align: top; "> </td><td style="width: 80%; vertical-align: top; "><p>
      Google Cloud Messaging for Android (GCM) es un servicio que faculta enviar datos desde su servidor a los usuarios con dispositivos Android. Puede tratarse simplemente de un pequeño mensaje que diga a la aplicación que hay nuevos datos para ser descargados desde el servidor (por ejemplo, que un amigo ha subido un nuevo vídeo) u otro mensaje que contenga hasta 4KiB de información (por lo que las aplicaciones como las de mensajería instantánea pueden consumirlo directamente).
    </p><p>
      El servicio GCM maneja todos los aspectos del encolamiento de los mensajes y entrega a la aplicación Android determinada que se puede ejecutar en el dispositivo.
    </p></td><td style="width: 10%; vertical-align: top; "> </td></tr><tr><td style="width: 10%; vertical-align: top; "> </td><td style="text-align: right; vertical-align: top; " colspan="2">--<span class="attribution">GCM: Google Cloud Messaging for Android</span></td></tr></table></div><div class="figure" id="idp33488"><div class="figure-title">Figura 2.6. GCM logo</div><div class="figure-contents"><div style="text-align: justify; " class="mediaobject"><table style="border: 0; width: 354; cellpadding: 0; cellspacing: 0;"><tr><td style="text-align: justify; "><img style="text-align: justify; width: 354; " src="../../resources/gcm-logo.png" alt="GCM logo"/></td></tr></table></div></div></div><br class="figure-break"/><p><span class="formalpara-title">Características. </span>GCM tiene como características más interesantes:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          La aplicación a la que tiene que llegar la notificación no tiene por qué estar abierta. El servicio GCM se encarga de despertarla y de que maneje la notificación.
        </p></li><li class="listitem"><p>
          No hay ninguna interfaz para administrar la notificacición. GCM simplemente pasa datos en crudo desde que la notificación es recibida hasta que es entregada. La aplicación final es la goza de la lógica necesaria para saber qué hacer con la notificación en todo momento. Por ejemplo, puede que la notificación sea "hay nuevos datos para descargar", por lo que no muestre ninguna interfaz, o bien un nuevo mensaje de un amigo, que sí es importante mostrar.
        </p></li><li class="listitem"><p>
          Requiere que la versión de Android instalada sea la 2.2 y además es necesario que posea la aplicación de Google Play (el antiguo Market) configurada correctamente, es decir, una cuenta de Google asociada. Pero no obliga a que la aplicación que reciba la notificación esté instalada por Google Play, si no que puede tener cualquier origen.
        </p></li><li class="listitem"><p>
          Usa una conexión permanente con los servidores de Google para recibir las notificaciones y mensajes de control.
        </p></li><li class="listitem"><p>
          Requiere que los servidores de terceros que envíen notificaciones estén registrados en la plataforma. Esto significa que Google puede revocar en cualquier momento el envío de notificaciones por parte de un desarrollador o empresa, simplemente no permitiendo el identificador único que se les proporciona en un primer momento.
        </p></li><li class="listitem"><p>
          La identificación de la aplicación es de forma única. Esto significa que para cada aplicación que quiera recibir notificaciones push, en cada dispositivo, tiene un número único que la identifica de forma única dentro del servicio. Esta identificación única la proporciona el servidor de GCM a la aplicación, que a su vez tiene que enviarla al servidor de terceros para que se destine concretamente a esa instancia.
        </p></li></ul></div><p>
    </p><p>
    El diagrama principal del envío y entrega de un mensaje de una forma muy abstracta es:
  </p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h3 class="title">Nota</h3><p>
      Se supone que la aplicación instalada tiene un ID de registro que permite recibir notificaciones, además de que el servidor de terceros ha guardado ese ID y el servidor tiene una clave de API que le permite identificarse como emisor de notificaciones.
    </p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>El servidor de aplicación envía un mensaje a los servidores de GCM.</p></li><li class="listitem"><p>El servicio GCM encola el mensaje y lo guarda en el caso de que el dispositivo al que se tiene que entregar esté desconectado.</p></li><li class="listitem"><p>Cuando el dispositivo se encuentre online (puede que ya lo esté, o puede que no), el mensaje es mandado por un canal al dispositivo, que lo parsea el sistema operativo (Android, en este caso), y despierta a la aplicación destino en el caso de que esté cerrada o la entrega directamente.</p></li><li class="listitem"><p>La aplicación procesa el mensaje y realiza cualquier tipo de evento relacionado con ella: sincronizar datos de fondo, mostrar una alerta…</p></li></ol></div><p>
    GCM es un sistema que no es obligatorio para las aplicaciones Android publicadas en el Market de Google. Sin embargo, su diseño le convierte en algo bastante eficaz para las redes móviles y le confiere una serie de ventajas que hacen que los servicios de terceros tengan que disponer de menos lógica y preocuparse en menor medida de la suerte que van a correr sus mensajes.
  </p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h3 class="title">Nota</h3>
    Cabe señalar, que antes de la introducción de GCM para los desarrolladores de Android (en julio de 2012), había un sistema muy similar para teléfonos Android, llamado Cloud to Device Messagging, o más conocido como C2DM<a href="#ftn.idp304320" class="footnote"><sup class="footnote" id="idp304320">[10]</sup></a></div><p><span class="formalpara-title">Ventajas. </span>
      GCM tiene una serie de ventajas sobre su predecesor CD2M (no explicado puesto que ha sido sustituido por esta versión) de las cuales habría que distinguir:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Atesora un mejor uso de batería, ya que puede encolar mensajes para ser entregados cuando el dispositivo está con una conexión activa (y por lo tanto tiene la radio móvil activada). Además, no tiene por qué notificar al dispositivo siempre que le llegue una nueva notificación, si no que puede esperar a que pase a estar activo (por ejemplo, que se encienda la pantalla) para mandar los datos.
        </p></li><li class="listitem"><p>
          El uso de datos y la transferencia es más eficiente, según las explicaciones del punto anterior. Esto lleva a un menor uso de batería y a que el usuario sólo pueda recibir notificaciones cuando realmente sean interesantes: cuando se usa el dispositivo y mantener en cola las no prioritarias.
        </p></li><li class="listitem"><p>
          El API es más sencilla, puesto que hay menos pasos para poder usar el servicio y además, el código del cliente en las aplicaciones es más claro y fácil de implementar, sobrescribiendo algunos métodos de las clases de las cuales se extiende.
        </p></li><li class="listitem"><p>
          La migración del servicio es muy simple y sólo hay que cambiar la URL de push para que apunte hacia otro servidor.
        </p></li><li class="listitem"><p>
          Se eliminan las cuotas que había en el sistema anterior, permitiendo a los desarrolladores crecer de forma sencilla y sin nuevas peticiones. Igualmente, se puede consultar el estado de los mensajes en el perfil de Google.
        </p></li><li class="listitem"><p>
          Permiten un mensaje (<code class="code">payload</code>) de 4KiB, por lo que muchos de los datos que puedan ir por esta mensajería push no requerirán que las aplicaciones se conecten al servidor de terceros para recoger la información y realizar una segunda conexión.
        </p></li><li class="listitem"><p>
          Posibilitan los mensajes multicast, es decir, se puede realizar un sólo envío de mensaje push, pero indicando todos los receptores en el momento de enviarlo para que se entregue a todos. Incluso múltiples emisores pueden enviar mensajes a una misma aplicación (por ejemplo, una red social que habla sobre un jugador de fútbol y a la vez información sobre el equipo en el que juega).
        </p></li><li class="listitem"><p>
          Hay un tiempo de vida máximo de 4 semanas para cada mensaje. Si un mensaje viene sin tiempo de vida, se presupone que el tiempo es máximo, sin embargo, un mensaje muy interesante es del de un TTL (<code class="code">time_to_live</code>) de 0 segundos, el cual se envía a los receptores sin guardarlo, de forma que si no está conectado el receptor (o los receptores), se pierde.
        </p></li><li class="listitem"><p>
          Existe la posibilidad de sobrescribir mensajes antiguos (con la misma <code class="code">collapse_key</code>), enviar mensajes sólo cuando el usuario esté activo (con <code class="code">delay_while_idle</code>) e incluso comprobar si los mensajes van a ser entregados o no, dependiendo de la respuesta que aporte el servicio.
        </p></li></ul></div><p>
    A pesar de la enorme capacidad de la que dispone este sistema, con todas las ventajas explicadas anteriormente, sigue teniendo pequeños fallos que hacen que no sea ampliamente usado, por ejemplo:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="formalpara-title">No es obligatorio. </span>
            Por lo que los diferentes desarrolladores no están obligados a usarlo en sus aplicaciones y pueden crear otros sistemas de push propietarios (como los que hacen la mayoría de aplicaciones de mensajería instantánea), lo que lleva a que la validez del sistema sea menor.
          </p></li><li class="listitem"><p><span class="formalpara-title">Mantiene una conexión abierta. </span>
            Como se ha comentado, uno de los grandes problemas, junto a la señalización, es la de mantener canales abiertos sin hacer nada a la espera de que alguna vez atraviese un dato, en este caso, notificaciones. 
          </p></li></ol></div><p>
  </p><div class="figure" id="idp322560"><div class="figure-title">Figura 2.7. Funcionamiento de GCM</div><div class="figure-contents"><div style="text-align: left; " class="mediaobject"><table style="border: 0; width: 602; cellpadding: 0; cellspacing: 0;"><tr><td style="text-align: left; "><img style="text-align: left; width: 602; " src="../../resources/apns-gcm.png" alt="Funcionamiento de GCM"/></td></tr></table></div></div></div><br class="figure-break"/><p><span class="formalpara-title">Arquitectura. </span>
      Así pues, se puede observar el flujo completo de trabajo de GCM:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          En la primera utilización del servicio, el teléfono dotado con Android (la única plataforma que soporta GCM por el momento) tiene que disponer de una cuenta de correo válida en el sistema (de GMail o de Google Apps), a la cual se asociará un identificador único de dispositivo. Asimismo, también se enviará una petición para recibir una cadena única que identificará a una aplicación en un dispositivo en concreto.
        </p></li><li class="listitem"><p>
          La aplicación que pidió la identificación, la recibe del servidor GCM.
        </p></li><li class="listitem"><p>
          La aplicación manda, por su propio canal de comunicación que haya decidido, dicho token único a un servidor de terceros, con algún tipo de identificación de usuario o de instancia que permitirá enviar contenido personalizado. Por ejemplo, si una persona registrada desea recibir notificaciones sólo sobre su equipo favorito, se tiene que enviar el dato que identifique a esa persona/usuario con el identificador enviado.
        </p></li><li class="listitem"><p>
          El dispositivo abre y mantiene una conexión TCP persistente con el servidor de GCM, mandando mensajes de keep-alives (que viene a ser un "sigo vivo") en intervalos de tiempo determinados. Estos intervalos son, por defecto, de 28 minutos, pero varía dependiendo del país y de la operadora, e incluso de forma adaptativa.
        </p></li><li class="listitem"><p>
          En cualquier momento, el servidor de terceros (llamado Application Server) manda un mensaje push al servidor GCM con los parámetros que se especifican en el servicio, incluyendo el identificador de dispositivo recibido en el paso 2 y enviado en el paso 3.
        </p></li><li class="listitem"><p>
          GCM envía, en la medida de sus posibilidades, el mensaje al dispositivo a través del canal TCP abierto, ya sea de forma inmediata, o bien con los parámetros indicados en el paso anterior (como <code class="code">delay_while_idle</code> o <code class="code">time_to_live</code>).
        </p></li></ol></div><p><span class="formalpara-title">Problemas. </span>
      Sin embargo, a pesar de todas las nuevas características y todo lo que ha trabajado Google en este sistema, existen varios problemas que podrían llegar a ser bastante graves derivando en una no confianza hacia este sistema.
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Se necesita mantener siempre una conexión abierta, por lo que sigue ocupando espacio en la red móvil, y en concreto en el GGSN (GPRS Support Node), que es un hardware con un precio muy elevado donde se mantiene abierta cada conexión, hasta un límite de 65535.
        </p></li><li class="listitem"><p>
          Esa única conexión requiere de keep-alives para mantenerse activa, por lo que cada cierto tiempo se estará cambiando de estado radio, con su correspondiente señalización, indicando simplemente que se está conectado.
        </p></li><li class="listitem"><p>
          Es un punto único de fallo (SPOF: Single Point Of Failure) son los servidores de Google, por lo que si caen, la infraestructura también lo hace, y no hay posibilidad de cambiar a otra, dado que el protocolo es cerrado y propietario.
        </p></li><li class="listitem"><p>
          Todos los mensajes van por los servidores de Google, por lo que puede constituir un posible riesgo de seguridad, más aún viendo las diferentes leyes para regular Internet que han salido desde Estados Unidos, donde Google tiene su sede.
        </p></li><li class="listitem"><p>
          No hay garantía sobre el orden de entrega de los mensajes, por lo que algunos de estos enviados posteriormente podrían llegar antes que uno enviado previamente. De esta forma, no se pueden crear dependencias entre mensajes.
        </p></li></ul></div></section><section xml:lang="es" class="section" id="state_art_Internet_apns"><div class="titlepage"><div><div><h3 class="title">APNS: Apple Push Notification Service</h3></div></div></div><p>
    APNS o Apple Push Notification Service es otro de los sistemas creado por empresas fabricantes de sistemas operativos para solventar el problema de notificaciones push, en este caso para dispositivos iOS, como el iPhone o el iPad.
  </p><p>
    Este sistema es muy similar en comportamiento a GCM pero con alguna variación, sobre todo en los tipos de mensajes que puede enviar los desarrolladores y en el tratamiento de las notificaciones por el usuario, que se expondrá más adelante.
  </p><p><span class="formalpara-title">Historia. </span>
      Fue lanzado con la versión 3.0 de iOS, el 17 de junio de 2009, que correspondía . Ha sido mejorado con el paso del tiempo e introducido en los equipos de escritorio con la versión 10.7 de MacOS usando el centro de notificaciones, también presente en iOS 5 y posteriores.
    
      Su primera versión fue retrasada algunos meses debido a los problemas de escalabilidad que se estaban teniendo en el sistema por la gran avalancha de peticiones y uso que estaban dando los desarrolladores a este sistema<a href="#ftn.idp434432" class="footnote"><sup class="footnote" id="idp434432">[11]</sup></a>.
    </p><p><span class="formalpara-title">Características. </span>
      Este sistema posee una serie de características que no tienen los demás métodos de notificaciones push, las cuales son:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        Usa un protocolo binario para el envío de datos, bajo una conexión TCP cruda. Esto hace que el tamaño de las notificaciones y de los mensajes de control sea más pequeño, pero a la vez sea más difícil de descifrar, puesto que el protocolo es cerrado.
      </p></li><li class="listitem"><p>
        Su uso es muy amplio y obligatorio para todas las aplicaciones certificadas por Apple (todas aquellas que estén en su tienda de aplicaciones) en vez de implementar servicios de polling.
      </p></li><li class="listitem"><p>
        Hay un canal de escucha de feedback, por lo que se puede saber si las notificaciones se han enviado correctamente o no. Además, también informa sobre de-registros de aplicaciones y dispositivos.
      </p></li><li class="listitem"><p>
        Está controlado absolutamente por Apple, pudiendo censurar y eliminar dispositivos y servidores que estén haciendo un uso indebido de su infraestructura.
      </p></li></ul></div><p><span class="formalpara-title">Ventajas. </span>
      En primer lugar, se van a enumerar las diferentes ventajas que tiene sobre sus competidores:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        Mayor seguridad: las notificaciones recibidas para aplicaciones que están en segundo plano o cerradas, no son enviadas directamente, si no que se muestran en la barra de estado, y hasta que el usuario no pulsa y las acepta, no se envían a la aplicación, añadiendo un nivel más de seguridad, la aceptación del usuario.
      </p></li><li class="listitem"><p>
        Funcional tanto en los dispositivos móviles, como iPad o iPhone, como en los sistemas de escritorio, tipo MacOS X, a partir de su versión 10.7, siendo el API el mismo para ambos sistemas.
      </p></li><li class="listitem"><p>
        Permite tres tipos diferentes de notificaciones, que se adecuan a diferentes opciones visuales y sonoras:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><span class="formalpara-title">Badges. </span>
              Muestra una imagen o número en el icono de la aplicación.
            </p></li><li class="listitem"><p><span class="formalpara-title">Alerta/Banners. </span>
              Muestra un aviso en el centro de la pantalla.
            </p></li><li class="listitem"><p><span class="formalpara-title">Sonido. </span>
              Reproduce un sonido determinado.
            </p></li></ul></div></li></ul></div><p><span class="formalpara-title">Problemas. </span>
      Sin embargo, hay una serie de desventajas que merece la pena reseñar:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        Protocolo muy cerrado y sin posibilidad de implementaciones de terceros, en ningún sistema operativo.
      </p></li><li class="listitem"><p>
        El payload que pueden llevar las notificaciones es como mucho de 256 KiB, lo que hace que muchas aplicaciones necesiten una segunda conexión para recoger los datos reales, ya que pueden ocupar más de lo permitido.
      </p></li><li class="listitem"><p>
        El servidor que envía las notificaciones debe tener abierta otra conexión con un servidor de feedback de Apple para recibir el estado de las entregas.
      </p></li><li class="listitem"><p>
        Demasiada burocracia: creación de certificados ad-hoc, certificados SSL, es necesario registro, para probar se tienen que utilizar un dispositivo en concreto registrado con Apple…
      </p></li><li class="listitem"><p>
        Sistema centralizado y propenso a que si hay un fallo, ningún dispositivo de Apple pueda recibir notificaciones.
      </p></li><li class="listitem"><p>
        Cuotas muy estrictas: un mensaje por aplicación y hasta un máximo de 100 por dispositivo.
      </p></li></ul></div><p>
    Como se puede observar, es un sistema bastante más limitado que GCM, con menores opciones, mayor control sobre lo que pueden hacer las aplicaciones y los desarrolladores, pero con la ventaja de que funciona en todos los sistemas operativos de Apple.
  </p></section><section xml:lang="es" class="section" id="state_art_Internet_thialfi"><div class="titlepage"><div><div><h3 class="title">Thialfi: el futuro de Google</h3></div></div></div><p>
    Thialfi es un nuevo protocolo diseñado y publicado por Google<a href="#ftn.idp463184" class="footnote"><sup class="footnote" id="idp463184">[12]</sup></a> que trata de arreglar algunos de los problemas de los sistemas de notificaciones: el paso de mensajes completos a través de la red y el consiguiente inconveniente de infraestructura y escalabilidad que podría resultar de tener millones de terminales conectados a la vez mandando muchos mensajes a través de la red y en espera para ser entregados.
  </p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h3 class="title">Nota</h3><p>
      Sin embargo, cabe observar que este sistema no está funcionando en los terminales móviles que llevan Android, sino que se usa el ya explicado GCM, sólo con la intención de explorar nuevas posibilidades, así como la sincronización de contactos de manera experimental. Lo implementa Google Chrome en su versión de escritorio y móvil.
    </p></div><p>
    El principal cambio entre GCM y Thialfi es la vuelta de mensajes que no llevan contenido útil para la aplicación, si no que se basan en mandar números de versión sobre temas en concreto ("topics") a los que el usuario y las aplicaciones se suscriben para mantenerse en sincronía.
  </p><p><span class="formalpara-title">Características. </span>
      Por consiguiente, Thialfi guarda una serie de mejoras con respecto a los otros sistemas:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="formalpara-title">Escalable. </span>
          Puede tener constancia de millones de clientes y de objetos, ya que el tamaño para ambos es pequeño, sin necesidad de guardar datos finales, si no simplemente números de versión.
        </p></li><li class="listitem"><p><span class="formalpara-title">Rápido. </span>
          Según las pruebas y el paper original, la entrega de los mensajes, en este caso mensajes con números de versión, se realiza en menos de 1 segundo desde que el servidor de terceros manda un mensaje hasta que el cliente lo recibe.
        </p></li><li class="listitem"><p><span class="formalpara-title">Seguro. </span>
          Incluso si un centro de datos se cae, el sistema es capaz de recuperarse, volviendo a registrar los diferentes dispositivos y eventualmente regresando a un estado correcto.
        </p></li><li class="listitem"><p><span class="formalpara-title">Fácil de usar. </span>
          Las APIs son sencillas y han sido implementadas en diferentes servicios utilizados por Google, como la sincronización de datos de Chrome, contactos y en Google+.
        </p></li></ul></div><p>
    Entonces, tal y como se ha expuesto en los puntos anteriores, todo son objetos que poseen identificadores (<code class="code">ID</code>) únicos y números de versión que incrementan de forma monótona en cada actualización.
  </p><p><span class="formalpara-title">Ventajas. </span>
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="formalpara-title">Menos datos guardados. </span>
          Es una de las ventajas, pero a la vez es un gran inconveniente. Sólo hay que guardar los objetos que contienen un identificador y un número de versión, por lo que las bases de datos (BigTable, que usan en Google) necesitan menos espacio para poder funcionar, al no guardar mensajes (en GCM el <code class="code">payload</code> máximo es de 4KiB). Además, sólo es necesario guardar el último mensaje para cada aplicación-objeto (básicamente es aumentar el número de versión), mientras que en un sistema como GCM se requiere guardar múltiples mensajes.
        </p></li><li class="listitem"><p><span class="formalpara-title">No hay fugas de datos privados. </span>
          Dado que las notificaciones no tienen mensaje, no hay riesgo de fuga de datos privados, puesto que lo único que se transmite son números de versión, que no dicen nada sobre el contenido.
        </p></li><li class="listitem"><p><span class="formalpara-title">Entrega siempre actualizada. </span>
          La entrega de los mensajes está asegurada, no porque siempre se tenga la última versión en un momento determinado, si no porque seguro que se va a conocer esa versión en un momento futuro. Esto quiere decir que lo único que reciben los clientes es un número de versión de un determinado objeto, que siempre es el máximo posible. Así pues, si un cliente se ha quedado desactualizado en, por ejemplo, la versión <code class="code">17</code>, y ha llegado la <code class="code">18</code> y no ha podido ser entregada, cuando llegue la versión <code class="code">19</code> el cliente sabrá que tiene que pedir tanto la <code class="code">18</code> como la <code class="code">19</code>, para así estar en sincronía con el servidor, de manera que en cualquier momento lo único que almacena un servidor o un cliente es un determinado objeto, con un <code class="code">ID</code> en una versión <code class="code">V</code> determinada.
        </p></li><li class="listitem"><p><span class="formalpara-title">Buena recuperación ante errores. </span>
          Thialfi tiene una serie de mensajes de control que permiten recuperar el estado de los registros en caso de fallo. Por ejemplo, si el servidor pierde todos los registros, se envía un mensaje a los clientes para que ejecuten <code class="code">ReissueRegistrations()</code>, y se inicia un protocolo para devolver los registros.
        </p></li><li class="listitem"><p><span class="formalpara-title">Fácil implementación del cliente. </span>
          El número de líneas requeridas para la implementación en el cliente es muy bajo, debido a su uso basado en eventos y su fácil lógica, en la siguiente figura se pueden ver algunos ejemplos:
        </p><div class="figure" id="idp491872"><div class="figure-title">Figura 2.8. Líneas de código para implementar Thialfi</div><div class="figure-contents"><div style="text-align: left; " class="mediaobject"><table style="border: 0; width: 461; cellpadding: 0; cellspacing: 0;"><tr><td style="text-align: left; "><img style="text-align: left; width: 461; " src="../../resources/thialfi-sloc.png" alt="Líneas de código para implementar Thialfi"/></td></tr></table></div></div></div><br class="figure-break"/><p>
        Como se puede observar, varía dependiendo del lenguaje de programación, desde las 40 u 80 en Google Contacts y Google+ hasta las 535 bajo un protocolo XMPP en Chrome Sync.
      </p><p>
        Además, lo interesante que se ve en esta figura anterior es que Thialfi no obliga un único protocolo de aplicación, si no que puede funcionar sobre varios, como conexiones HTTP, XMPP o incluso RPC.
      </p></li></ul></div><p><span class="formalpara-title">Problemas. </span>
      Sin embargo, aunque aporta muchas ventajas, como las que están enumeradas anteriormente, cuenta con problemas de cara a ser un buen servidor para datos en la red móvil
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="formalpara-title">Doble conexión para recuperar datos. </span>
          En un sistema en el que los servicios de terceros pueden enviar datos de payload, obliga a que el servidor de notificaciones sea más complejo, por el hecho de guardar datos. Sin embargo, esto puede significar que los clientes no tengan que abrir una segunda conexión para recuperar los datos necesarios debido a que el propio mensaje de notificación ya lo tiene. Esto, a pesar de parecer un problema menor, constituye uno de los grandes inconvenientes en las redes móviles, donde realizar una conexión es una operación muy costosa (en términos de tiempo y de señalización) y la descarga de los datos es lenta.
        </p></li><li class="listitem"><p><span class="formalpara-title">Mayor complejidad en el servidor. </span>
          Esto se debe a que requiere guardar los cambios o diferencias para que cuando se conecten los diferentes clientes, puedan recuperar los datos que pidan, como por ejemplo, los datos de la versión <code class="code">17</code>. Sin embargo, puede haber casos en los que los clientes no vayan a pedir la última versión, si no la versión <code class="code">16</code> y <code class="code">17</code>. Por lo que el servidor debe mantener esas diferencias de algún modo (en formato delta o con mensajes completos).
        </p></li><li class="listitem"><p><span class="formalpara-title">Mayor complejidad en las aplicaciones. </span>
          Esto es debido a que las aplicaciones no van a procesar el mensaje directamente, si no que tienen que discernir cuál es el número de versión, hacer una llamada al servidor de terceros y recibir los datos. Además, se ha de tener en cuenta que pueden solicitarse diferentes versiones para acabar en sincronía con el servidor, lo que aumenta la lógica para ver qué versión está dando el servidor y cómo se puede manejar con versiones más nuevas.
        </p></li><li class="listitem"><p><span class="formalpara-title">Servidores de aplicación más potentes. </span>
          El primer problema es la necesidad de que todos los clientes, una vez recibido un número de versión, tengan que conectarse obligatoriamente con el servidor de la aplicación para descargar los datos, lo que podría conllevar muchísima capacidad de cálculo (si por ejemplo los datos hay que calcularlos al vuelo y dependen de cada petición) y de ancho de banda, así como de medidas para evitar que muchos usuarios se conecten a la vez y puedan colapsar los sistemas.
        </p></li></ul></div><p>
    En definitiva, Thialfi puede considerarse como un posible candidato a complementar y no a sustituir a GCM, por las desventajas ya explicadas. La necesidad de crear una segunda conexión y los posibles problemas que puede acarrear a los servidores de aplicación trabajar con millones de peticiones, hace que no sea escalable para pequeñas empresas y malo para dispositivos móviles. Sin embargo, en la práctica se ha demostrado que es competente, aunque con grandes granjas de servidores como los centros de datos de Google.
  </p></section><div class="footnotes"><br/><hr class="footnote-hr"/><div id="ftn.idp28752" class="footnote"><p><a href="#idp28752" class="para"><sup class="para">[8] </sup></a>http://developer.android.com/google/gcm/index.html</p></div><div id="ftn.idp30464" class="footnote"><p><a href="#idp30464" class="para"><sup class="para">[9] </sup></a>A fecha de 12 de septiembre de 2012, http://news.cnet.com/8301-1035_3-57510994-94/google-500-million-android-devices-activated/</p></div><div id="ftn.idp304320" class="footnote"><p><a href="#idp304320" class="para"><sup class="para">[10] </sup></a>https://developers.google.com/android/c2dm/</p></div><div id="ftn.idp434432" class="footnote"><p><a href="#idp434432" class="para"><sup class="para">[11] </sup></a>http://www.engadget.com/2008/06/09/iphone-push-notification-service-for-devs-announced/</p></div><div id="ftn.idp463184" class="footnote"><p><a href="#idp463184" class="para"><sup class="para">[12] </sup></a>http://research.google.com/pubs/pub37474.html</p></div></div></section><footer><div class="navfooter"><hr/><table style="width: 100%; "><tr><td style="width: 40%; text-align: left; "><a accesskey="p" href="ch02s02.xhtml">Anterior</a> </td><td style="width: 20%; text-align: center; "><a accesskey="u" href="ch02.xhtml">Subir</a></td><td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch03.xhtml">Siguiente</a></td></tr><tr><td style="width: 40%; text-align: left; vertical-align: top; ">Operadores </td><td style="width: 20%; text-align: center; "><a accesskey="h" href="index.xhtml">Inicio</a></td><td style="width: 40%; text-align: right; vertical-align: top; "> Capítulo 3. API</td></tr></table></div></footer></body></html>
