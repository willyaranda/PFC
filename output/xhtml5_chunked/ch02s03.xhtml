<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Internet</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="prev" href="ch02s02.xhtml" title="Operadores"/><link rel="next" href="ch03.xhtml" title="Capítulo 3. Application Program Interface, API"/></head><body><header><div class="navheader"><table style="width: 100%; "><tr><th style="text-align: center; " colspan="3">Internet</th></tr><tr><td style="width: 20%; text-align: left; "><a accesskey="p" href="ch02s02.xhtml">Anterior</a> </td><th style="width: 60%; text-align: center; ">Capítulo 2. Estado del arte</th><td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch03.xhtml">Siguiente</a></td></tr></table><hr/></div></header><section xml:lang="es" class="section" id="state_art_Internet_main"><div class="titlepage"><div><div><h2 class="title" style="clear: both">Internet</h2></div></div></div><p>
    Una vez visto las diferentes plataformas push creadas por los organismos de los operadores de telefonía móvil, y que seguir explicando otros mecanismos, yendo hacia tecnologías más modernas y que han sido creadas por empresas radicadas principalmente en Internet. Estas tecnologías son relativamente similares entre ellas, pero se difieren en las cuotas, autenticación… pero la idea sobre cómo mantener el canal de comunicación entre los dispositivos y el servidor de notificaciones es muy similar.
  </p><p>
    Así pues, a continuación se ven cada una de estas tecnologías y a explicarlas brevemente.
  </p><section xml:lang="es" class="section" id="state_art_Internet_gcm"><div class="titlepage"><div><div><h3 class="title">GCM: Google Could Messaging</h3></div></div></div><p>
    GCM o Google Cloud Messaging<a href="#ftn.idp217760" class="footnote"><sup class="footnote" id="idp217760">[8]</sup></a> es un sistema de notificaciones push creado por la empresa Google para su sistema operativo Android. Su finalidad es la misma que los demás sistemas: entregar notificaciones o mensajes que un servicio de terceros (o incluso la misma plataforma de Google) a los usuarios usando un dispositivo de una manera fácil, ordenada y controlada.
  </p><p>
    Lanzado en julio de 2012, es uno de los sistemas más grandes, puesto que está presente en todos los dispositivos Android que tengan una cuenta de Google asociada, los cuales son prácticamente la mayoría. El número de usuarios de este servicio no es especificado por Google, pero podría ser similar o inferior al número de dispositivos Android en el mercado, que supera los 500 millones de dispositivos<a href="#ftn.idp219488" class="footnote"><sup class="footnote" id="idp219488">[9]</sup></a>.
  </p><div class="blockquote"><table style="border: 0; width: 100%; cellspacing: 0; cellpadding: 0;" class="blockquote"><tr><td style="width: 10%; vertical-align: top; "> </td><td style="width: 80%; vertical-align: top; "><p>
      Google Cloud Messaging for Android (GCM) es un servicio que te permite enviar datos desde tu servidor a los usuarios con dispositivos Android. Esto puede ser un pequeño mensaje que dice a la aplicación que hay nuevos datos para ser descargados desde el servidor (por ejemplo, que un amigo ha subido un nuevo vídeo) o un mensaje que puede contener hasta 4KiB de información (por lo que las aplicaciones como las de mensajería instantánea pueden consumirlo directamente).
    </p><p>
      El servicio GCM maneja todos los aspectos del encolamiento de los mensajes y entrega a la aplicación Android determinada que se puede ejecutar en el dispositivo.
    </p></td><td style="width: 10%; vertical-align: top; "> </td></tr><tr><td style="width: 10%; vertical-align: top; "> </td><td style="text-align: right; vertical-align: top; " colspan="2">--<span class="attribution">GCM: Google Cloud Messaging for Android</span></td></tr></table></div><p><span class="formalpara-title">Características. </span>GCM tiene como características más interesantes:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          La aplicación a la que tiene que llegar la notificación no tiene por qué estar abierta. El servicio GCM se encarga de despertarla y que maneje la notificación.
        </p></li><li class="listitem"><p>
          No hay ninguna interfaz para administrar la notificacición. GCM simplementa pasa datos en crudo desde que la notificación es recibida hasta que es entregada. La aplicación final es la que tiene la lógica necesaria para saber qué hacer con la notificación en todo momento. Por ejemplo, puede que la notificación sea "hay nuevos datos para descargar", por lo que no muestre ninguna interfaz, o bien un nuevo mensaje de un amigo, que sí es importante mostrar.
        </p></li><li class="listitem"><p>
          Requiere que la versión de Android instalada sea la 2.2 y además tiene que tener la aplicación de Google Play (el antiguo Market) configurada correctamente, esto es, con una cuenta de Google asociada. Pero no obliga a que la aplicación que reciba la notificación esté instalada por Google Play, si no que puede tener cualquier origen.
        </p></li><li class="listitem"><p>
          Usa una conexión permanente con los servidores de Google para recibir las notificaciones y mensajes de control.
        </p></li><li class="listitem"><p>
          Requiere que los servidores de terceros que envíen notificaciones estén registrados en la plataforma. Esto significa que Google puede revocar en cualquier momento el envío de notificaciones por parte de un desarrollador o empresa, simplemente no permitiendo el identificador único que se les proporciona en un primer momento.
        </p></li><li class="listitem"><p>
          La identificación de la aplicación es de forma única. Esto significa que para cada aplicación que quiera recibir notificaciones push, en cada dispositivo, tiene un número único que la identifica de forma única dentro del servicio. Esta identificación única la da el servidor de GCM a la aplicación, que a su vez la tiene que enviar al servidor de terceros para que se envíe concretamente a esa instancia.
        </p></li></ul></div><p>
    </p><p>
    Así pues, el diagrama principal del envío y entrega de un mensaje de una forma muy abstracta es:
  </p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h3 class="title">Nota</h3><p>Se supone que la aplicación instalada tiene un ID de registro que permite recibir notificaciones, además de que el servidor de terceros ha guardado ese ID y que el servidor tiene una clave de API que le permite identificarse como emisor de notificaciones.</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>El servidor de aplicación envía un mensaje a los servidores de GCM.</p></li><li class="listitem"><p>El servicio GCM encola el mensaje y lo guarda en el caso de que el dispositivo al que se tiene que entregar esté desconectado.</p></li><li class="listitem"><p>Cuando el dispositivo se encuentre online (puede que ya lo esté, o puede que no), el mensaje es mandado por un canal al dispositivo, que lo parsea el sistema operativo (Android, en este caso), y despierta a la aplicación destino en el caso que esté cerrada o la entrega directamente.</p></li><li class="listitem"><p>La aplicación procesa el mensaje y realiza cualquier tipo de evento relacionado con ella: sincronizar datos de fondo, mostrar una alerta…</p></li></ol></div><p>
    GCM es un sistema que no es obligatorio para las aplicaciones Android publicadas en el Market de Google, sin embargo, su diseño hace que sea bastante eficiente para las redes móviles y haya un buen puñado de ventajas que hacen que los servicios de terceros tengan que tener menos lógica y preocuparse menos de la suerte que van a correr sus mensajes.
  </p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h3 class="title">Nota</h3>
    Cabe señalar, que antes de la introducción de GCM para los desarrolladores de Android (en julio de 2012), antes había un sistema muy similar para teléfonos Android, llamado Cloud to Device Messagging, o más conocido como C2DM<a href="#ftn.idp237600" class="footnote"><sup class="footnote" id="idp237600">[10]</sup></a></div><p><span class="formalpara-title">Ventajas. </span>
      GCM tiene una serie de ventajas sobre su predecesor CD2M (no explicado puesto que ha sido sustituido por esta versión) de las cuales habría que destacar:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Tiene un mejor uso de batería, ya que puede encolar mensajes para ser entregados cuando el dispositivo está con una conexión activa (y por lo tanto tiene la radio móvil activada). Además, no tiene por qué notificar al dispositivo siempre que le llegue una nueva notificación, si no que puede esperar a que pase a estar activo (por ejemplo, que se encienda la pantalla) para mandar los datos.
        </p></li><li class="listitem"><p>
          El uso de datos y la transferencia es más eficiente, por las explicaciones del punto anterior. Esto hace que se gaste menos batería y que el usuario sólo pueda recibir notificaciones cuando realmente son interesantes: cuando se usa el dispositivo, y mantener en cola las no prioritarias.
        </p></li><li class="listitem"><p>
          El API es más sencilla, puesto que hay menos pasos para poder usar el servicio y además, el código del cliente en las aplicaciones es más claro y fácil de implementar, sobrescribiendo algunos métodos de las clases de las cuales se extiende.
        </p></li><li class="listitem"><p>
          La migración del servicio es muy simple, y sólo hay que cambiar la URL de push para que apunte hacia otro servidor.
        </p></li><li class="listitem"><p>
          Se eliminan las cuotas que había en el sistema anterior, permitiendo a los desarrolladores crecer de forma sencilla y sin nuevas peticiones. Además, se pueden consultar el estado de los mensajes en el perfil de Google.
        </p></li><li class="listitem"><p>
          Permiten un mensaje (<code class="code">payload</code>) de 4KiB, por lo que muchos de los datos que puedan ir por esta mensajería push no requerirán que las aplicaciones se conecten al servidor de terceros para recoger la información y realizar una segunda conexión.
        </p></li><li class="listitem"><p>
          Se permiten hacer mensajes multicast, esto quiere decir que se puede hacer sólo un envío de mensaje push, pero indicando todos los receptores en el momento de enviarlo, se entregarán a todos. Incluso múltiples emisores pueden enviar mensajes a una misma aplicación (por ejemplo, una red social que habla sobre un jugador de fútbol y a la vez información sobre el equipo en el que juega).
        </p></li><li class="listitem"><p>
          Hay un tiempo de vida máximo de 4 semanas para cada mensaje. Si un mensaje viene sin tiempo de vida, se presupone que el tiempo es máximo, sin embargo, un mensaje muy interesante es del de un TTL (<code class="code">time_to_live</code>) de 0 segundos, el cual se envía a los receptores sin guardarlo, por lo que si no está conectacto el receptor (o los receptores), se pierde.
        </p></li><li class="listitem"><p>
          Existe la posibilidad de sobrescribir mensajes antiguos (con la misma <code class="code">collapse_key</code>), enviar mensajes sólo cuando el usuario esté activo (con <code class="code">delay_while_idle</code>) e incluso comprobar si los mensajes van a ser entregados o no dependiendo de la respuesta que de el servicio.
        </p></li></ul></div><p>
    A pesar de la enorme capacidad que tiene este sistema, con todas sus ventajas que se han mostrado anteriormente, sigue teniendo pequeños fallos que hacen que no sea ampliamente usado, por ejemplo:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="formalpara-title">No es obligatorio. </span>
            Por lo que los diferentes desarrolladores no están obligados a usarlo en sus aplicaciones y pueden crear otros sistemas de push propietarios (como los que hacen la mayoría de aplicaciones de mensajería instantánea), lo que lleva a que la validez del sistema sea menor.
          </p></li><li class="listitem"><p><span class="formalpara-title">Mantiene una conexión abierta. </span>
            Como se ha comentado, uno de los grandes problemas, junto a la señalización, es la de mantener canales abiertos sin hacer nada en espera de que alguna vez atraviese un dato, en nuestro caso notificaciones. 
          </p></li></ol></div><p>
  </p><div class="figure" id="idp188608"><div class="figure-title">Figura 2.3. Funcionamiento de GCM</div><div class="figure-contents"><div style="text-align: left; " class="mediaobject"><table style="border: 0; width: 602; cellpadding: 0; cellspacing: 0;"><tr><td style="text-align: left; "><img style="text-align: left; width: 602; " src="../../resources/apns-gcm.png" alt="Funcionamiento de GCM"/></td></tr></table></div></div></div><br class="figure-break"/><p><span class="formalpara-title">Arquitectura. </span>
      Así pues, se puede observar el flujo completo de trabajo de GCM:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
          En la primera utilización del servicio, el teléfono dotado con Android (la única plataforma que soporta GCM por el momento) tiene que disponer de una cuenta de correo válida en el sistema (de GMail o de Google Apps), a la cual se asociará un identificador único de dispositivo. Además, también se enviará una petición para recibir una cadena única que identificará a una aplicación en un dispositivo en concreto.
        </p></li><li class="listitem"><p>
          La aplicación que pidió la identificación, la recibe del servidor GCM.
        </p></li><li class="listitem"><p>
          La aplicación manda, por su propio canal de comunicación que haya decidido, dicho token único a un servidor de terceros, con algún tipo de identificación de usuario o de instancia que permitirá enviar contenido personalizado. Por ejemplo, si una persona registrada desea recibir notificaciones sólo sobre su equipo favorito, se tiene que enviar el dato que identifique a esa persona/usuario con el identificador enviado.
        </p></li><li class="listitem"><p>
          El dispositivo abre y mantiene una conexión TCP persistente con el servidor de GCM, mandando mensajes de keep-alives (que viene a ser un "sigo vivo") en intervalos de tiempo determinados. Estos intervalos son, por defecto, de 28 minutos, pero varía dependiendo del país y de la operadora, e incluso de forma adaptativa.
        </p></li><li class="listitem"><p>
          En cualquier momento, el servidor de terceros (llamado Application Server) manda un mensaje push al servidor GCM con los parámetros que se especifican en el servicio, incluyendo el identificador de dispositivo recibido en el paso 2 y enviado en el paso 3.
        </p></li><li class="listitem"><p>
          GCM envía, en la medida de sus posibilidades, el mensaje al dispositivo a través del canal TCP abierto, ya sea de forma inmediata, o bien con los parámetros indicados en el paso anterior (como <code class="code">delay_while_idle</code> o <code class="code">time_to_live</code>).
        </p></li></ol></div><p><span class="formalpara-title">Problemas. </span>
      Sin embargo, a pesar de todas las nuevas características y todo lo que ha trabajado Google en este sistema, hay varios problemas que pueden ser bastante graves y que harían que no confiáramos en este sistema
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          Se necesita mantener siempre una conexión abierta, por lo que sigue ocupando espacio en la red móvil, y en concreto en el GGSN (GPRS Support Node), que es un hardware con un precio muy elevado que es donde se mantienen cada conexión abierta que tengamos, hasta un límite de 65535.
        </p></li><li class="listitem"><p>
          Esa única conexión requiere de keep-alives para mantenerse activa, por lo que cada cierto tiempo se estará cambiando de estado radio, con su correspondiente señalización, para indicar simplemente que estamos conectados.
        </p></li><li class="listitem"><p>
          Es un punto único de fallo (SPOF: Single Point Of Failure) son los servidores de Google, por lo que si caen, la infraestructura cae, y no hay posibilidad de cambiar a otra, puesto que el protocolo es cerrado y propietario.
        </p></li><li class="listitem"><p>
          Todos los mensajes van por los servidores de Google, por lo que puede ser un posible riesgo de seguridad, más aún viendo las diferentes leyes para regular Internet que han salido desde los EE.UU, que es donde Google está radicada.
        </p></li><li class="listitem"><p>
          No hay garantía sobre el orden de entrega de los mensajes, por lo que algunos de estos enviados posteriormente podrían llegar antes que uno enviado previamente. De esta forma, no se pueden crear dependencias entre mensajes.
        </p></li></ul></div></section><section xml:lang="es" class="section" id="state_art_Internet_apns"><div class="titlepage"><div><div><h3 class="title">APNS: Apple Push Notification Service</h3></div></div></div><p>
    TODO XXX
    APNS o Apple Push Notification Service es otro de los sistemas creado por empresas creadoras de sistemas operativos para solventar el problema de notificaciones push, en este caso para dispositivos iOS, como el iPhone o el iPad.
  </p><p>
    Este sistema es muy similar en comportamiento a GCM pero con alguna variación, sobre todo en los tipos de mensajes que puede enviar los desarrolladores y cómo se tratan las notificaciones por el usuario.
  </p><p><span class="formalpara-title">Historia. </span>
      Fue lanzado con la versión 3.0 de iOS, el 17 de junio de 2009, que correspondía . Ha sido mejorado con el paso del tiempo e introducido en los equipos de escritorio con la versión 10.7 de MacOS usando el centro de notificaciones, también presente en iOS 5.
    </p><p><span class="formalpara-title">Características. </span>

    </p><p><span class="formalpara-title">Ventajas. </span>

    </p><p><span class="formalpara-title">Problemas. </span>

    </p></section><section xml:lang="es" class="section" id="state_art_Internet_thialfi"><div class="titlepage"><div><div><h3 class="title">Thialfi: el futuro de Google</h3></div></div></div><p>
    Thialfi es un nuevo protocolo diseñado y publicado por Google<a href="#ftn.idp379744" class="footnote"><sup class="footnote" id="idp379744">[11]</sup></a> que intenta arreglar algunos de los problemas que tienen los sistemas de notificaciones que pasan mensajes completos a través de la red, y el consiguiente problema de infraestructura y escalabilidad que podría resultar de tener millones de terminales conectados a la vez mandando muchos mensajes a través de la red y en espera de ser entregados.
  </p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h3 class="title">Nota</h3><p>
      Sin embargo, cabe notar que este sistema no está funcionando en los terminales móviles que llevan Android, si no que se usa el ya explicado GCM, y este es sólo con la intención de explorar nuevas posibilidades, y lo implementa Google Chrome en su versión de escritorio y móvil, así como la sincronización de contactos de manera experimental.
    </p></div><p>
    El principal cambio entre GCM y Thialfi es la vuelta de mensajes que no llevan contenido útil para la aplicación, si no que se basan en mandar números de versión sobre temas en concreto ("topics") a los que el usuario y las aplicaciones se suscriben para mantenerse en sincronía.
  </p><p><span class="formalpara-title">Características. </span>
      Así pues, Thialfi tiene una serie de mejoras con respecto a los otros sistemas, como son:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="formalpara-title">Escalable. </span>
          Puede tener constancia de millones de clientes y de objetos, ya que el tamaño para ambos es pequeño, sin tener que guardar datos finales, si no simplemente números de versión.
        </p></li><li class="listitem"><p><span class="formalpara-title">Rápido. </span>
          Según las pruebas y el paper original, la entrega de los mensajes, en este caso mensajes con números de versión, se realizan en menos de 1 segundo desde que el servidor de terceros manda un mensaje hasta que el cliente lo recibe.
        </p></li><li class="listitem"><p><span class="formalpara-title">Seguro. </span>
          Incluso si un centro de datos se cae, el sistema es capaz de recuperarse, volviendo a registrar los diferentes dispositivos y enventualmente volviendo a un estado correcto.
        </p></li><li class="listitem"><p><span class="formalpara-title">Fácil de usar. </span>
          Las APIs son sencillas y ha sido implementadas en diferentes servicios usados por Google, como en la sincronización de datos de Chrome, contactos y en Google+.
        </p></li></ul></div><p>
    Entonces, como se comenta en los puntos anteriores, todo son objetos que poseen identificadores (<code class="code">ID</code>) únicos y números de versión que incrementan de forma monótona en cada actualización.
  </p><p><span class="formalpara-title">Ventajas. </span>
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="formalpara-title">Menos datos guardados. </span>
          Es una de las ventajas, pero a la vez es un gran inconveniente. Sólo hay que guardar los objetos que contienen un identificador y un número de versión, por lo que las bases de datos (BigTable, que usan en Google) necesitan menos espacio para poder funcionar, al no guardar mensajes (en GCM el <code class="code">payload</code> máximo es de 4KiB). Además, sólo es necesario guardar el último mensaje para cada aplicación-objeto (básicamente es aumentar el número de versión), mientras que en un sistema como GCM hay que guardar múltiples mensajes.
        </p></li><li class="listitem"><p><span class="formalpara-title">No hay fugas de datos privados. </span>
          Al no tener mensaje las notificaciones, no hay riesgo de fuga de datos privados, puesto que lo único que se transmite son números de versión, que no dicen nada sobre el contenido.
        </p></li><li class="listitem"><p><span class="formalpara-title">Entrega siempre actualizada. </span>
          La entrega de los mensajes está asegurada, no porque siempre se tenga la última versión en un momento determinado, si no porque seguro que se va a conocer esa versión en un momento futuro. Esto quiere decir que lo único que reciben los clientes es un número de versión de un determinado objeto, que siempre es el máximo posible, por lo que si se tiene un cliente que se ha quedado desactualizado en, digamos, la versión <code class="code">17</code>, y ha llegado la <code class="code">18</code> y no ha podido ser entregada, cuando llegue la versión <code class="code">19</code> el cliente sabrá que tiene que pedir tanto la <code class="code">18</code> como la <code class="code">19</code>, para estar en sincronía con el servidor, por lo que en cualquier momento lo único que almacena un servidor o un cliente es un determinado objecto, con un <code class="code">ID</code> en una versión <code class="code">V</code> determinada.
        </p></li><li class="listitem"><p><span class="formalpara-title">Buena recuperación ante errores. </span>
          Thialfi tiene una serie de mensajes de control que permiten recuperar el estado de los registros en caso de fallo. Por ejemplo, si el servidor pierde todos los registros, se envía un mensaje a los clientes para que ejecuten <code class="code">ReissueRegistrations()</code>, y se inicia un protocolo para devolver los registros.
        </p></li><li class="listitem"><p><span class="formalpara-title">Fácil implementación del cliente. </span>
          El número de líneas requeridas para la implementación en el cliente es muy bajo, debido a su uso basado en eventos y su fácil lógica, en la siguiente figura se pueden ver algunos ejemplos:
        </p><div class="figure" id="idp408400"><div class="figure-title">Figura 2.4. Líneas de código para implementar Thialfi</div><div class="figure-contents"><div style="text-align: left; " class="mediaobject"><table style="border: 0; width: 461; cellpadding: 0; cellspacing: 0;"><tr><td style="text-align: left; "><img style="text-align: left; width: 461; " src="../../resources/thialfi-sloc.png" alt="Líneas de código para implementar Thialfi"/></td></tr></table></div></div></div><br class="figure-break"/><p>
        Como se puede observar, varía dependiendo del lenguaje de programación, desde las 40 u 80 en Google Contacts y Google+ hasta las 535 bajo un protocolo XMPP en Chrome Sync.
      </p><p>
        Además, lo interesante que se ve en esta figura anterior es que Thialfi no obliga un único protocolo de aplicación, si no que puede funcionar sobre varios, como conexiones HTTP, XMPP o incluso RPC.
      </p></li></ul></div><p><span class="formalpara-title">Problemas. </span>
      Sin embargo, aunque tiene muchas ventajas, como las están enumeradas anteriomente, tiene problemas para ser un buen servidor para datos en la red móvil
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="formalpara-title">Doble conexión para recuperar datos. </span>
          En un sistema en el que los servicios de terceros pueden enviar datos de payload, obliga a que el servidor de notificaciones sea más complejo, por el hecho de que tiene que guardar datos. Sin embargo, esto puede significar que los clientes no tengan que abrir una segunda conexión para recuperar los datos necesarios debido a que el propio mensaje de notificación ya lo tiene. Esto, a pesar de parecer un problema menor, es uno de los grandes problemas en las redes móviles, donde realizar una conexión es muy costoso (en términos de tiempo y de señalización) y la descarga de los datos lenta.
        </p></li><li class="listitem"><p><span class="formalpara-title">Mayor complejidad en el servidor. </span>
          Esto es debido a que requiere que se guarden los cambios o diferencias para cuando se conecten los diferentes clientes, puedan recuperar los datos que pidan, como por ejemplo, los datos de la versión <code class="code">17</code>. Sin embargo, puede haber casos en que los clientes no vayan a pedir la última versión, si no que tengan que pedir la versión <code class="code">16</code> y <code class="code">17</code>. Por lo que el servidor tiene que mantener esas diferencias de algún modo (en formato delta o con mensajes completos).
        </p></li><li class="listitem"><p><span class="formalpara-title">Mayor complejidad en las aplicaciones. </span>
          Esto es debido a que las aplicaciones no van a procesar el mensaje directamente, si no que tienen que discernir cuál es el número de versión, hacer una llamada al servidor de terceros y recibir los datos. Además, hay que tener en cuenta que pueden pedirse diferentes versiones para acabar en sincronía con el servidor, lo que aumenta la lógica para ver qué versión está dando el servidor y cómo se puede manejar con versiones más nuevas.
        </p></li><li class="listitem"><p><span class="formalpara-title">Servidores de aplicación más potentes. </span>
          El primer problema es la necesidad de que todos los clientes, una vez recibido un número de versión, tengan que obligatoriamente conectarse con el servidor de la aplicación para descargar los datos, lo que puede conllevar a muchísima capacidad de cálculo (si por ejempo los datos hay que calcularlos al vuelo y dependen de cada petición) y de ancho de banda, así como de medidas para evitar que muchos usuarios se conecten a la vez y puedan colapsar los sistemas.
        </p></li></ul></div><p>
    Así pues, puede verse a Thialfi como un posible candidado a complementar, que no sustituir, a GCM, por los problemas mostrados más arriba. La necesidad de crear una segunda conexión, y los posibles problemas que puede acarrear a los servidores de aplicación el tener que trabajar con millones de peticiones, hace que no sea escalable para pequeñas empresas y malo para dispositivos móviles. Sin embargo, en la práctica se ha demostrado que es competente, pero con grandes granjas de servidores como los centros de datos de Google.
  </p></section><div class="footnotes"><br/><hr class="footnote-hr"/><div id="ftn.idp217760" class="footnote"><p><a href="#idp217760" class="para"><sup class="para">[8] </sup></a>http://developer.android.com/google/gcm/index.html</p></div><div id="ftn.idp219488" class="footnote"><p><a href="#idp219488" class="para"><sup class="para">[9] </sup></a>A fecha de 12 de septiembre de 2012, http://news.cnet.com/8301-1035_3-57510994-94/google-500-million-android-devices-activated/</p></div><div id="ftn.idp237600" class="footnote"><p><a href="#idp237600" class="para"><sup class="para">[10] </sup></a>https://developers.google.com/android/c2dm/</p></div><div id="ftn.idp379744" class="footnote"><p><a href="#idp379744" class="para"><sup class="para">[11] </sup></a>http://research.google.com/pubs/pub37474.html</p></div></div></section><footer><div class="navfooter"><hr/><table style="width: 100%; "><tr><td style="width: 40%; text-align: left; "><a accesskey="p" href="ch02s02.xhtml">Anterior</a> </td><td style="width: 20%; text-align: center; "><a accesskey="u" href="ch02.xhtml">Subir</a></td><td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch03.xhtml">Siguiente</a></td></tr><tr><td style="width: 40%; text-align: left; vertical-align: top; ">Operadores </td><td style="width: 20%; text-align: center; "><a accesskey="h" href="index.xhtml">Inicio</a></td><td style="width: 40%; text-align: right; vertical-align: top; "> Capítulo 3. Application Program Interface, API</td></tr></table></div></footer></body></html>
