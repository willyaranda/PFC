<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Capítulo 5. Tecnologías</title><link rel="stylesheet" type="text/css" href="docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/><link rel="prev" href="ch04s02.xhtml" title="Flujos de trabajo"/><link rel="next" href="ch05s02.xhtml" title="RabbitMQ"/></head><body><header><div class="navheader"><table style="width: 100%; "><tr><th style="text-align: center; " colspan="3">Capítulo 5. Tecnologías</th></tr><tr><td style="width: 20%; text-align: left; "><a accesskey="p" href="ch04s02.xhtml">Anterior</a> </td><th style="width: 60%; text-align: center; "> </th><td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch05s02.xhtml">Siguiente</a></td></tr></table><hr/></div></header><section xml:lang="es" class="chapter" id="technologies"><div class="titlepage"><div><div><h1 class="title">Capítulo 5. Tecnologías</h1></div></div></div><div class="toc"><div class="toc-title">Tabla de contenidos</div><ul><li><span class="section"><a href="ch05.xhtml#idp561088">Node.js</a></span><ul><li><span class="section"><a href="ch05.xhtml#idp580096">Para qué se usa</a></span></li><li><span class="section"><a href="ch05.xhtml#idp582496">Por qué se ha elegido</a></span></li></ul></li><li><span class="section"><a href="ch05s02.xhtml">RabbitMQ</a></span><ul><li><span class="section"><a href="ch05s02.xhtml#idp124704">Para qué se usa</a></span></li><li><span class="section"><a href="ch05s02.xhtml#idp128384">Por qué se ha elegido</a></span></li></ul></li><li><span class="section"><a href="ch05s03.xhtml">MongoDB</a></span><ul><li><span class="section"><a href="ch05s03.xhtml#idp485872">Para qué se usa</a></span></li><li><span class="section"><a href="ch05s03.xhtml#idp487488">Por qué se ha elegido</a></span></li></ul></li></ul></div><p>
    Ahora, una vez hablado de cómo es la arquitectura y la primera implementación, hay que comentar sobre las tecnologías usadas y por qué se han escogido para la parse del servidor, comparando con otras soluciones similares.
  </p><p>
    Así pues, una de las grandes decisiones que hay que tomar al iniciar un proyecto de software son las tecnologías y lenguajes de programación que se van a utilizar, incluyendo a las herramientas, editores, gestores de bugs y de incidencias, método de comentarios en el código y un sin fin de características que harán derivar el proyecto hacia el éxito o el fracaso.
  </p><section class="section" id="idp561088"><div class="titlepage"><div><div><h2 class="title" style="clear: both">Node.js</h2></div></div></div><p>
      Node.js<a href="#ftn.idp561984" class="footnote"><sup class="footnote" id="idp561984">[17]</sup></a> es un nuevo paradigma de programación para aplicaciones web en la parte del servidor, basado en JavaScript, muy rápido y con una serie de características muy importantes, como se verá más adelante.
    </p><div class="blockquote"><table style="border: 0; width: 100%; cellspacing: 0; cellpadding: 0;" class="blockquote"><tr><td style="width: 10%; vertical-align: top; "> </td><td style="width: 80%; vertical-align: top; "><p>
        Node.js es una plataforma creada sobre el intérprete de JavaScript de Chrome para crear fácilmente aplicaciones de red rápidas y escalables. Node.js usa un sistema de eventos, un modelo de entrada-salida no bloqueante que hace que sea ligero y eficiente, perfecto para aplicaciones en tiempo real que requieran un uso intensivo de datos y que funcione a través de dispositivos distribuidos.
      </p></td><td style="width: 10%; vertical-align: top; "> </td></tr><tr><td style="width: 10%; vertical-align: top; "> </td><td style="text-align: right; vertical-align: top; " colspan="2">--<span class="attribution">Node.js</span></td></tr></table></div><p>
      Esta nueva plataforma surgió en el año 2009 por Ryan Dahl, y es patrocinada por la empresa Joyent, y su creación se debió a la necesidad de crear un sistema que pudiera trabajar correctamente con sitios web que aceptaran peticiones push para el intercambio de datos, por lo que la idea de esta tecnología era especialmente interesante para el proyecto del servidor de notificaciones.
    </p><p>
      Está compuesta de diferentes paquetes independientes, que son:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="formalpara-title">Motor JavaScript V8 de Google Chrome. </span>
            Un intérprete creado ad-hoc para Google Chrome, que revolucionó a la competencia por ser el más rápido y usar unas ideas muy novedosas e inteligentes. Genera código máquina para varias plataformas, como 32-bits, 64-bits, ARM o MIPS antes de ejecutar el código, en vez de directamente interpretarlo como hacían otros motores JavaScript. Además, utiliza una serie de técnicas antes de ejecutar que permiten optimizar (en varios pasos) y cachear resultados de partes del código que se usan mucho, como bucles o algunas funciones.
          </p></li><li class="listitem"><p><span class="formalpara-title">La capa de abstracción libUV. </span>
            Node.js se basó en la librería <code class="code">libev</code> de abstracción de plataforma que estaba solamente disponible para Linux. Una vez que el desarrollo continuó y fue necesario utilizar otras plataformas, como Windows, se decidió crear <code class="code">libUV</code>, que no es más que la evolución de <code class="code">libev</code> para soportar otras plataformas y dar un API estándar para los desarrolladores de forma transparente al sistema que lo está ejecutando.
          </p><p>
          libUV contiene la mayoría de las características que luego definen a Node.js. Así pues, se implementan sockets TCP no bloqueantes, tuberías, el protocolo UDP, temporizadores, creación de procesos hijos e hilos, paso de mensajes vía IPC y sockets, varias funciones asíncronas como DNS o acceso a ficheros del disco…
        </p><p>
            Así pues, livuv obliga a un estilo de programación asíncrono y basado en eventos, y su trabajo principal es el de proveer un bucle de eventos y notificaciones basadas en callbacks para operaciones de entrada y salida y otras actividades.
        </p></li><li class="listitem"><p><span class="formalpara-title">Núcleo. </span>
            Escrito principalmente en JavaScript haciendo uso de las API e interfaces que provee V8 y otros módulos para un trabajo comunitario, es el código principal que después, mediante otras APIs se expone al desarrollador que va a utilizar Node.js.
          </p><p>
          Así pues, es posible encontrar módulos como el de criptografía<a href="#ftn.idp574480" class="footnote"><sup class="footnote" id="idp574480">[18]</sup></a> (<code class="code">crypto</code>) escritos enteramente en C, haciendo uso de las extensiones de V8, mientras que por ejemplo el que provee la interfaz para el manejo de sistemas de ficheros<a href="#ftn.idp575632" class="footnote"><sup class="footnote" id="idp575632">[19]</sup></a> (<code class="code">fs</code>) está enteramente escrito en JavaScript, y su sintaxis es más fácil de entender y leer.
        </p></li></ul></div><p>
      Para su diseño se tomó ideas prestadas de otros sistemas similares, como es Twisted para Python, libevent para C o EventMachine par Ruby. La mayoría de los programas en JavaScript se ejecutan en el contexto del navegador, puesto que siempre han sido los mayores exponenentes y consumidores de este lenguaje, sin embargo, Node.js es ejecutado en la parte del servidor, e incluso puede ser usado como lenguaje de scripting (sustituyendo incluso a Bash o Python) y posee un REPL, una consola interactiva.
    </p><p><span class="formalpara-title">Usuarios. </span>
        Actualmente Node.js, a pesar de ser una tecnología muy reciente y joven, está siendo usada por muchas grandes empresas de Internet para escalar sus sistemas. El hecho de que Yahoo! haya empezado a migrar algunos de sus sistemas desde PHP hacia Node.js, implementando diferenes frameworks y módulos mientras hacían la transición, hace pensar que el recorrido de esta plataforma es muy amplio y con muchas empresas grandes detrás interesadas en que siga siendo funcional, agregue más módulos y características y que sea líder en el mercado de los desarrollos de servicios de backend. Además, Microsoft, LinkedIn (para su aplicación móvil) o incluso Walmart también han decidido cambiar algunos de sus sistemas para hacer uso de Node.js.
      </p><section class="section" id="idp580096"><div class="titlepage"><div><div><h3 class="title">Para qué se usa</h3></div></div></div><p>
          Node.js se utiliza en la parte del backend como la programación lógica del servidor de notificaciones. Esto quiere decir que es el que controla todo lo que está ocurriendo en el servicio, expone las APIs de terceros, mantiene las conexiones abiertas, hace intercambio de datos, guarda en la base de datos, monitoriza los mensajes por si hay que borrarles y un sin fín más de funcionalidades.
        </p><p>
          Así pues, es el componente principal del servicio, el que está en continuo contacto con el mensaje enviado, desde la entrada, incluyendo la verificación, hasta la entrega a los diferentes terminales a los que iba dirigido. Es el maestro de ceremonias que hace que todo funcione correctamente.
        </p></section><section class="section" id="idp582496"><div class="titlepage"><div><div><h3 class="title">Por qué se ha elegido</h3></div></div></div><p>
        Hay multitud de tecnologías para programar servicios web, pasando por cientos de diferentes lenguajes de programación que proveen miles de frameworks diferentes entre los que elegir. Sin embargo, una tecnología robusta, sencilla, con mucha comunidad detrás para buscar cualquier duda y tener un montón de módulos ha hecho que el proyecto se decantara por Node.js por las siguientes razones:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Es asíncrono y basado en eventos, lo que permite mucha más granularidad y no bloquear la ejecución. Además, no se tienen que lanzar hilos por cada petición (o varias), si no que está todo en un bucle de eventos al que se van añadiendo acciones.
          </p></li><li class="listitem"><p>
            Es JavaScript, y está alineado con la tecnología del proyecto que lo engloba, que es FirefoxOS.
          </p></li><li class="listitem"><p>
            Es muy rápido de programar y se pueden hacer pruebas de concepto de forma rápida, además, que sea JavaScript ayuda a detectar de forma más fácil los errores, y que el tiempo desde hacer un cambio hasta verlo reflejado sea mínimo, sin tener que esperar a grandes tiempos de compilación.
          </p></li><li class="listitem"><p>
            Despliegue muy sencillo y con multitud de opciones, ya que permite elegir si se quiere correr detrás de un balanceador de carga (como HAProxy), directamente conectado a la red y que sea Node.js el que responda…
          </p></li></ul></div><p>
        Así pues, aunque hay otras elecciones posibles, como podría ser PHP, o incluso Python con pyev<a href="#ftn.idp108592" class="footnote"><sup class="footnote" id="idp108592">[20]</sup></a>, el que se creyó que tendría menos uso de CPU y memoria y tendría más posibilidades de ser "hackeado" por la comunidad, fue Node.js.
      </p></section></section><div class="footnotes"><br/><hr class="footnote-hr"/><div id="ftn.idp561984" class="footnote"><p><a href="#idp561984" class="para"><sup class="para">[17] </sup></a>http://nodejs.org/</p></div><div id="ftn.idp574480" class="footnote"><p><a href="#idp574480" class="para"><sup class="para">[18] </sup></a>https://github.com/joyent/node/blob/master/src/node_crypto.cc</p></div><div id="ftn.idp575632" class="footnote"><p><a href="#idp575632" class="para"><sup class="para">[19] </sup></a>https://github.com/joyent/node/blob/master/lib/fs.js</p></div><div id="ftn.idp108592" class="footnote"><p><a href="#idp108592" class="para"><sup class="para">[20] </sup></a>https://code.google.com/p/pyev/</p></div></div></section><footer><div class="navfooter"><hr/><table style="width: 100%; "><tr><td style="width: 40%; text-align: left; "><a accesskey="p" href="ch04s02.xhtml">Anterior</a> </td><td style="width: 20%; text-align: center; "> </td><td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch05s02.xhtml">Siguiente</a></td></tr><tr><td style="width: 40%; text-align: left; vertical-align: top; ">Flujos de trabajo </td><td style="width: 20%; text-align: center; "><a accesskey="h" href="index.xhtml">Inicio</a></td><td style="width: 40%; text-align: right; vertical-align: top; "> RabbitMQ</td></tr></table></div></footer></body></html>
