<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Notification Server</title><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"/></head><body><div xml:lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a id="push_notification_server_architecture"/>Notification Server</h1></div><div><h2 class="subtitle">Architecture</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Fernando</span> <span class="surname">Rodríguez Sela</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Guillermo</span> <span class="surname">López Leal</span></h3></div></div></div><div><p class="copyright">Copyright © 2012 Telefónica Digital (PDI), All rights reserved.</p></div><div><div class="revhistory"><table summary="Revision History"><tr><th align="left" valign="top" colspan="3"><strong>Revision History</strong></th></tr><tr><td align="left">Revision 1.0</td><td align="left">November 2012</td><td align="left">FRS</td></tr><tr><td align="left" colspan="3">First Edition</td></tr></table></div></div></div><hr/></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#intro">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#idp33120">State of the art</a></span></dt><dd><dl><dt><span class="section"><a href="#idp36064">Current Internet solutions issues</a></span></dt></dl></dd><dt><span class="section"><a href="#idp39408">Service Description</a></span></dt></dl></dd><dt><span class="chapter"><a href="#network_issues">2. Mobile network issues with current PUSH platforms</a></span></dt><dd><dl><dt><span class="section"><a href="#idp88016">Mobile networks in a Private or Public LAN</a></span></dt><dt><span class="section"><a href="#idp90800">Mobile Network. Circuit domain states</a></span></dt><dt><span class="section"><a href="#idp104976">Mobile Network. Package domain states</a></span></dt><dt><span class="section"><a href="#idp110800">Mobile Network. States relation</a></span></dt><dt><span class="section"><a href="#idp136464">Mobile Network. Signalling storms</a></span></dt><dt><span class="section"><a href="#idp139104">Mobile Network. Battery comsuption</a></span></dt></dl></dd><dt><span class="chapter"><a href="#api">3. Notification server API</a></span></dt><dd><dl><dt><span class="section"><a href="#api_wa_ua">API between WebApp and the User Agent</a></span></dt><dt><span class="section"><a href="#api_ua_ns">API between the User Agent and the Notification Server</a></span></dt><dt><span class="section"><a href="#api_as_ns">API between the Application Server and the Notification Server</a></span></dt><dt><span class="section"><a href="#api_wa_as">API between the WA and the AS</a></span></dt><dt><span class="section"><a href="#api_tokens">Tokens</a></span></dt><dd><dl><dt><span class="section"><a href="#idp265680">WAToken</a></span></dt><dt><span class="section"><a href="#idp271728">UAToken</a></span></dt><dt><span class="section"><a href="#idp274112">AppToken</a></span></dt></dl></dd><dt><span class="section"><a href="#idp276336">WakeUp</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">4. Notification Server Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#idp162368">Technologies used</a></span></dt><dd><dl><dt><span class="section"><a href="#idp150880">MongoDB</a></span></dt><dt><span class="section"><a href="#idp73792">RabbitMQ</a></span></dt><dt><span class="section"><a href="#idp74816">Node.JS</a></span></dt></dl></dd><dt><span class="section"><a href="#idp75968">Types of servers</a></span></dt><dd><dl><dt><span class="section"><a href="#idp79008">NS-UA-WS</a></span></dt><dt><span class="section"><a href="#idp65776">NS-UA-UDP</a></span></dt><dt><span class="section"><a href="#idp67808">NS-WakeUp</a></span></dt><dt><span class="section"><a href="#idp70704">NS-AS</a></span></dt><dt><span class="section"><a href="#idp165616">NS-Monitor</a></span></dt><dt><span class="section"><a href="#idp167696">Message Queue (RabbitMQ)</a></span></dt><dt><span class="section"><a href="#idp169872">NO-SQL Database (MongoDB)</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#performance">5. Notification Server Performance</a></span></dt><dt><span class="chapter"><a href="#deployment">6. Notification Server Deployment</a></span></dt><dt><span class="chapter"><a href="#lessons_learned">7. Lessons learned</a></span></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>2.1. <a href="#idp112464">RCC - GMM relation</a></dt></dl></div><div class="list-of-examples"><p><strong>List of Examples</strong></p><dl><dt>3.1. <a href="#idp268080">Multiple device messages</a></dt><dt>3.2. <a href="#idp270272">Message broadcast</a></dt></dl></div><div xml:lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="intro"/>Chapter 1. Introduction</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#idp33120">State of the art</a></span></dt><dd><dl><dt><span class="section"><a href="#idp36064">Current Internet solutions issues</a></span></dt></dl></dd><dt><span class="section"><a href="#idp39408">Service Description</a></span></dt></dl></div><p>
    Today mobile applications retrieve asynchronously information from multiple sites.
    Developers have two ways to get this information:
  </p><p>
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
        Poll: Periodically query for information from the server.
      </li><li class="listitem">
        Push: The server sends the information to the client when the required
        information is available.
      </li></ul></div><p>
  </p><p>
    The first method is strongly discouraged due to the large number of connections
    made to the server needlessly, because information is not available and you lose time and resources.
  </p><p>
    That is why the PUSH methods are widely used for information retrieval,
    anyway how PUSH platforms are currently working are misusing mobile radio
    resources and also consuming too much battery.
  </p><p>
    This article aims to explain how to manage this kind of messaging, problems
    with existing solutions and finally how Telefónica Digital, within the framework
    of the development of Firefox OS operating system, defined a new solution which is
    friendlier to the network and uses lower battery consumption on mobile devices.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp33120"/>State of the art</h2></div></div></div><p>
      Historically, mobile operators offered (and offer) real mechanisms for PUSH notifications,
      also known as WAP PUSH. WAP PUSH can "wake up" applications when any action
      is required from them by the server side (without interaction from the user).
      Sending WAP PUSH messages is done in the circuit-switching domain, the same used
      for voice and SMS, and that is why the user don't need to establish a data connection.
      These kind messages work properly out of the box.
    </p><p>
      WAP PUSH solutions works great when the user is registered in the mobile network,
      but if you are out of coverage or connected to a WiFi hotspot instead a celular
      network, you can not receive these messages.
    </p><p>
      Also, if we add that this messages implies an economic cost (basically it
      is a short message SMS) the effect is that major smartphone operating systems
      (Apple iOS and Google Android) have implemented a parallel solution that would
      work regardless of the mobile network to which the user belongs and it can
      run smoothly when they are using WiFi networks.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp36064"/>Current Internet solutions issues</h3></div></div></div><p>
        Internet PUSH solutions are based on a public accesible server which handles
        all the notification delivery.
      </p><p>
        These solutions were designed without considering the mobile networks
        way of working and forces the handset to maintain an open socket with
        the server in order to avoid misnotifications.
      </p><p>
        This way of working increases the signalling and the handsets battery
        consume.
        For more information about this, please refer to the
        "<a class="xref" href="#network_issues" title="Chapter 2. Mobile network issues with current PUSH platforms">Mobile network issues with current PUSH platforms</a>" chapter
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp39408"/>Service Description</h2></div></div></div><p>
      The Notification Server platform is aimed to deliver push notifications
      (small messages like a real-time chat, a JSON data structure defining
      the goal of a soccer match) to web based terminals inside mobile networks.
    </p><p>
      The main objective of this service is to deliver these messages
      considering the way of working of the mobile radio so the battery
      consumption and traffic generated is reduced to the minimal.
      It is developed for working on stable Internet connections, like on
      Wi-Fi or Ethernet.
    </p></div></div><div xml:lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="network_issues"/>Chapter 2. Mobile network issues with current PUSH platforms</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#idp88016">Mobile networks in a Private or Public LAN</a></span></dt><dt><span class="section"><a href="#idp90800">Mobile Network. Circuit domain states</a></span></dt><dt><span class="section"><a href="#idp104976">Mobile Network. Package domain states</a></span></dt><dt><span class="section"><a href="#idp110800">Mobile Network. States relation</a></span></dt><dt><span class="section"><a href="#idp136464">Mobile Network. Signalling storms</a></span></dt><dt><span class="section"><a href="#idp139104">Mobile Network. Battery comsuption</a></span></dt></dl></div><p>
    This chapter explains why current solutions are bad for the mobile networks
    and how we designed this server to solve this issues.
  </p><p>
    In order to understand the complete problem, we need to introduce you on how
    the mobile nerworks work at radio level and also how the carriers have their
    network infrastructure. So, go ahead !
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp88016"/>Mobile networks in a Private or Public LAN</h2></div></div></div><p>
      Since on IPv4 the amount of free adresses is really low, celular networks
      were divided into the ones with real IPv4 adresses (normally for 3G modems)
      and private adressing model for handsets.
    </p><p>
      On the case of private networks, it's obvious that it's not possible to
      directly notify the handset when the server has a notification for it, so
      smartphone manufacturers decided to maintain opened channels with their
      servers so it's possible to notify handsets asynchronously.
    </p><p>
      On the other hand, if the handset has a public address, or is using IPv6,
      it's teorically possible to send the message directly making third party
      solutions unuseful, however in order to protect users, carriers can deploy
      firewalls to avoid direct access from Internet to the handset.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp90800"/>Mobile Network. Circuit domain states</h2></div></div></div><p>
      In the 3GPP TS 25.331 specification, we can query all the circuit domain
      statues of the RRC Layer (Radio Resource Control).
    </p><p>
      In order to simplify, we only list the third generation (3G) states:
      </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
          Cell_DCH (Dedicated Channel)
          <p>
            When the handset is in this state is because it has a dedicated
            channel on the mobile network.
          </p><p>
            Normally the network sets a handsent into this state when it's
            transmitting a big amount of data.
          </p><p>
            The inactivity time of this state is really short, known as T1 timer
            it should vary between 5 and 20 seconds. If T1 is fired, the handset
            will be changed to the Cell_FACH state.
          </p></li><li class="listitem">
          Cell_FACH
          <p>
            In this state the handset is connected to the mobile network using
            a shared channel with other handsets.
          </p><p>
            Normally, this state is assigned by the network when the handset is
            transmitting a small amount of data.
            So it's common to use it when sending keep-alive packages.
          </p><p>
            The inactivity time of this state is a little longer (30 seconds) and
            is konwn as T2 timer. When T2 timer is shotted, the handset will be
            moved to Cell_PCH or URA_PCH (depending on the type of network)
          </p></li><li class="listitem">
          Cell_PCH or URA_PCH (PCH: Paging Channel) (URA: UTRAN Registration Area)
          <p>
            In this state the handset is not able to send any data except
            signalling information in order to be able to localize the handset
            inside the celullar network.
          </p><p>
            In both states, the RRC connection is established and open, but it's
            rarely used.
          </p><p>
            In this state, the handset informs the network every time the device
            change from one sector to another so the network is able to known
            exactly the BTS which is offering service to the device.
          </p><p>
            The T3 timer defines the maximum time to be in a PCH state. This timer
            is longer than T1 and T2 and depends on each carrier. When it's fired
            the handset is moved to IDLE mode so if new data transmission is needed
            the handset will need near 2 seconds to restablish the channel and a
            lot of signalling messages.
          </p></li><li class="listitem">
          RRC_IDLE
          <p>
            This is the most economical state since the handset radio is practically
            stopped.
          </p><p>
            In this state, the radio is only listening to radio messages quering
            the handset to "Wake Up" (paging messages).
          </p><p>
            Also, the handset modem is listening the cell data so each time it
            detects that the user changed from one LAC (Localization Area Code -
            Group of multiple BTS) to another, the handset will change to the
            PCH state in order to inform the network.
          </p><p>
            So when a handset is in this state, it can be Waked Up to a more
            active state and also the network knowns the LAC where the handset
            is moving, so if the network needs to inform the handset it should
            send a broadcast paging message through all the LAC BTS in order to
            locate the handset.
          </p></li></ul></div><p>
    </p><p>
      The following scheme represent the different radio states ordered by
      power comsuption on the device:
    </p><p>
      <img src="resources/rcc_states.png" style="text-align: middle" width="450"/>
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp104976"/>Mobile Network. Package domain states</h2></div></div></div><p>
      In the 3GPP TS 23.060 specification, we can analyse all the package domain
      states of the GMM Layer (GPRS Mobility Management).
    </p><p>
      The package domain states are simpler than radio ones (only 3 states):
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
        READY (2G) / PMM_CONNECTED (3G)
        <p>
          The handset has a PDP context established and is able to send and
          receive data.
        </p></li><li class="listitem">
        STANDBY (2G) / PMM_IDLE (3G)
        <p>
          The handset isn't transmitting anything but the PDP context is not
          closed, so it maintains a valid IP address.
        </p><p>
          In this state the handset don't consume any resource but the network is
          maintaining his IP address as a valid one, so it's very important to try
          to maintain the handset in this state in order to be able to Wake Up
          it and change to a PMM_CONNECTED state in order to transmit/receive
          information.
        </p></li><li class="listitem">
        IDLE (2G) / PMM_DETACHED (3G)
        <p>
          In this state, the handset hasn't a PDP context established so it hasn't
          a valid IP address.
        </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp110800"/>Mobile Network. States relation</h2></div></div></div><p>
      In this section we show the relation between RRC and GMM states.
    </p><p>
      In order to simplify this table, we only consider the handset is only using
      data channels, so no voice nor SMS (circuit domain) is being used.
    </p><div class="table"><a id="idp112464"/><p class="title"><strong>Table 2.1. RCC - GMM relation</strong></p><div class="table-contents"><table summary="RCC - GMM relation" border="1"><colgroup><col style="text-align: left" class="RCC"/><col style="text-align: left" class="GMM"/><col style="text-align: left" class="Desc"/></colgroup><thead><tr><th style="text-align: left">RCC State</th><th style="text-align: left">GMM State (2G/3G)</th><th style="text-align: left">Description</th></tr></thead><tfoot><tr><th style="text-align: left">RCC State</th><th style="text-align: left">GMM State (2G/3G)</th><th style="text-align: left">Description</th></tr></tfoot><tbody><tr><td style="text-align: left">Cell_DCH</td><td style="text-align: left">READY/PMM_CONNECTED</td><td style="text-align: left">
              <p>
                The handset is transmiting or receiving data information using a
                dedicated channel or a HSPA shared channel.
              </p>
            </td></tr><tr><td style="text-align: left">Cell_FACH</td><td style="text-align: left">READY/PMM_CONNECTED</td><td style="text-align: left">
              <p>
                The handset had been transmiting or receiving data some seconds ago
                and due to inactivity had been moved to the Cell_FACH RCC state.
              </p>
              <p>
                Also it's possible that the handset is transmiting or receiving
                small amount of data like pings, keep-alives, cell updates,...
              </p>
            </td></tr><tr><td style="text-align: left">Cell_PCH/URA_PCH</td><td style="text-align: left">READY/PMM_CONNECTED</td><td style="text-align: left">
              <p>
                The handset had been in Cell_FACH some seconds ago and due to
                inactivity had been moved to this less resource consume state.
              </p>
              <p>
                However, the signalling channel is available and is able to change
                to a data transmission state like FACH or DCH with a little amount
                of signalling.
              </p>
            </td></tr><tr><td style="text-align: left">Cell_PCH/URA_PCH</td><td style="text-align: left">STANDBY/PMM_IDLE</td><td style="text-align: left">
              <p>
                The handset is not transmiting nor receiving any amount of data
                and also the signalling connection is closed.
              </p>
              <p>
                However the IP address is maintained by the network and associated
                to this handset.
              </p>
              <p>
                This is one of the most interesting states since the PDP context
                is not closed, the IP address is still valid and the handset is
                not consuming baterry, network traffic,...
              </p>
              <p>
                As soon as the handset needs to restablish the data channel the
                radio state will be changed to FACH or DCH.
              </p>
            </td></tr><tr><td style="text-align: left">RRC_IDLE</td><td style="text-align: left">STANDBY/PMM_IDLE</td><td style="text-align: left">
              <p>
                This state is the same as the previous one since the radio state
                is IDLE.
              </p>
            </td></tr><tr><td style="text-align: left">RRC_IDLE</td><td style="text-align: left">IDLE/PMM_DETACHED</td><td style="text-align: left">
              <p>
                The handset is not transmitting nor receiving anything and also it
                hasn't any PDP context established, so no IP address is available
                for this handset.
              </p>
              <p>
                Normally this state is after 24h of innactivity in the package
                domain.
              </p>
            </td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp136464"/>Mobile Network. Signalling storms</h2></div></div></div><p>
      This is a carrier well-know effect after the big adoption of smartphones
      around the word.
    </p><p>
      As we explained in previous sections, each time the network decides to
      move a handset from one state to another is needed to restablish channels
      and starts a negotiation between the network and the handset with the
      signalling protocol.
    </p><p>
      Since nowadays handsets are sending keep-alives to maintain their connections
      opened, the efect is that the handsets is continously changing from one
      state to another producing a lot of signalling in the network and also
      consumes a lot of battery resources.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp139104"/>Mobile Network. Battery comsuption</h2></div></div></div><p>
      The battery comsuption depends on the Radio state. The following list
      represent the amount of battery needed on each state represented in
      relative units:
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">RRC IDLE: 1 relative unit</li><li class="listitem">Cell_PCH: &lt; 2 relative unit</li><li class="listitem">URA_PCH: &lt; or equal than Cell_PCH</li><li class="listitem">Cell_FACH: 40 relative units</li><li class="listitem">Cell_DCH: 100 relative units</li></ul></div></div></div><div xml:lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="api"/>Chapter 3. Notification server API</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#api_wa_ua">API between WebApp and the User Agent</a></span></dt><dt><span class="section"><a href="#api_ua_ns">API between the User Agent and the Notification Server</a></span></dt><dt><span class="section"><a href="#api_as_ns">API between the Application Server and the Notification Server</a></span></dt><dt><span class="section"><a href="#api_wa_as">API between the WA and the AS</a></span></dt><dt><span class="section"><a href="#api_tokens">Tokens</a></span></dt><dd><dl><dt><span class="section"><a href="#idp265680">WAToken</a></span></dt><dt><span class="section"><a href="#idp271728">UAToken</a></span></dt><dt><span class="section"><a href="#idp274112">AppToken</a></span></dt></dl></dd><dt><span class="section"><a href="#idp276336">WakeUp</a></span></dt></dl></div><p>
    The Notification Server API is based on the W3C draft:
    <a class="link" href="http://dvcs.w3.org/hg/push/raw-file/default/index.html">
      [http://dvcs.w3.org/hg/push/raw-file/default/index.html]
    </a>
  </p><p>
    In order to understand this chapter, we'll present the different actors:
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
        WebApp (WA):
        <p>
          The user's applications which is normally executed on the
          user device.
        </p></li><li class="listitem">
        User Agent (UA):
        <p>
          Since this protocol born under the Firefox OS umbrella the
          "operating system" layer is known as the User Agent layer, in our case
          is the Gecko engine.
        </p></li><li class="listitem">
        Notification Server (NS):
        <p>
          Centralized infrastructure of the notification
          server platform. This one can be freely deployed by anyone since it's
          open source:
          <a class="link" href="https://github.com/telefonicaid/notification_server">
            [https://github.com/telefonicaid/notification_server]
          </a>.
          The protocol also allows to use any server infrastructure the user wants
        </p></li><li class="listitem">
        Application server (AS):
        <p>
          The WA server side. Normally the applications that runs on a
          mobile device use one or more Internet servers.
        </p><p>
          Some of them will be deployed by the same developer as the client application.
        </p><p>
          In our case, this server will be the one which send the notification to
          his clients/users.
        </p></li></ul></div><p>
  </p><p>
    <img src="resources/actors_and_channels.png" style="text-align: middle" width="450"/>
  </p><div xml:lang="en" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="api_wa_ua"/>API between WebApp and the User Agent</h2></div></div></div><p>
    This API is mainly based on the W3C draft as specified in
    <a class="link" href="http://dvcs.w3.org/hg/push/raw-file/default/index.html">
      [http://dvcs.w3.org/hg/push/raw-file/default/index.html]
    </a>
  </p><p>
    With this API the application is able to register itself into the
    Notification Server and recover the public URL to be used as notification
    URL by his Application Server (AS).
  </p><p>
    This API (under the navigator.mozPush object) defines these methods:
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
        requestURL
      </li><li class="listitem">
        getCurrentURL
      </li></ul></div><p>
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp197856"/>navigator.mozPush.requestURL</h4></div></div></div><p>
        This method allows the application to register it self into the
        notification server.
        </p><pre class="programlisting">
        
        navigator.mozPush.requestURL(watoken, pbk)
        
        </pre><p>
      </p><p>
        This method should receive this two parameters:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
            watoken: The WA Token used to identify the user of the application.
            <p>
              The application developer can decide to use the same WAToken for
              all his users or a group of them so the notification will act
              as a broadcast message
            </p><p>
              It's very important to note that this token (mainly if used to
              identify one particular user) SHALL be a secret. It's recommended
              that this token will be generated by the server using a SHA hash
              based on the login details (as an identification cookie).
            </p><p>
              If this parameter is not provided, a randomized one will be
              generated by the UA engine.
            </p></li><li class="listitem">
            pbk: This parameter will contain a RSA Public key coded in BASE64.
            <p>
              This public key will be used by the notification server to
              validate the received messages signature, so the private key
              will be used by the AS to sign the messages.
            </p></li></ul></div><p>
      </p><p>
        It's under definition to send two parameters or only one which will be
        a JSON object:
        </p><pre class="programlisting">
        
        navigator.mozPush.requestURL({
          watoken: &lt;watoken&gt;,
          pbk: &lt;Base64 codified public key&gt;
        })
        
        </pre><p>
      </p><p>
        Finally this method will response asynchronously with the URL to be
        sent to the AS in order to be able to send notifications.
      </p><pre class="programlisting">
        
        var req = navigator.mozPush.requestURL(this.watoken, this.pbk);
        req.onsuccess = function(e) {
          alert("Received URL: " + req.result.url);
        };
        req.onerror = function(e) {
          alert("Error registering app");
        }
        
      </pre></div><p>

    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp206768"/>navigator.mozPush.getCurrentURL</h4></div></div></div><p>
        This method allows the application to recover a previously requested
        URL to the UA API, so it's not needed to ask for it to the
        notification server.
        </p><pre class="programlisting">
        
        navigator.mozPush.getCurrentURL()
        
        </pre><p>
      </p><p>
        This methods will response asynchronously with the URL to be
        sent to the AS in order to be able to send notifications.
      </p><pre class="programlisting">
        
        var req = navigator.mozPush.getCurrentURL();
        req.onsuccess = function(e) {
          alert("URL = " + req.result.url);
        };
        req.onerror = function(e) {
          alert("Error getting URL");
        }
        
      </pre></div><p>
  </p><p>
    After register the application into the Notification Server, all received
    notification through the given URL will be delivered to all user agents
    which registered the pair (WAToken + PBK).
  </p><p>
    Since the notifications will be received by the UA it's needed a way to
    notify each application. The current specification is using the new
    System Messages infrastructure defined in FirefoxOS.
  </p><p>
    In this case, the application shall register to the "push-notification"
    event handlser:
    </p><pre class="programlisting">
    
    navigator.mozSetMessageHandler("push-notification", function(msg) {
      alert("New Message with body: " + JSON.stringify(msg));
    });
    
    </pre><p>
  </p><p>
    The complete example:
    </p><pre class="programlisting">
      
      var req = navigator.mozPush.requestURL(this.watoken, this.pbk);
      req.onsuccess = function(e) {
        alert("Received URL: " + req.result.url);
        navigator.mozSetMessageHandler("push-notification", function(msg) {
          alert("New Message with body: " + JSON.stringify(msg));
        });
      };
      req.onerror = function(e) {
        alert("Error registering app");
      }
      
    </pre><p>
  </p></div><div xml:lang="en" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="api_ua_ns"/>API between the User Agent and the Notification Server</h2></div></div></div><p>
    With this API the client device is able to register his applications and
    itself into the selected notification server.
  </p><p>
    This API isn't yet standarised, anyway the one explained here is an 
    on working proposal.
  </p><p>
    The UA-NS API is divided in two transport protocols:
    </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
        POST API: Through the HTTP POST transport protocol the NS will deliver
        valid UATokens to the device.
      </li><li class="listitem">
        WebSocket API: This is the most important one since all the
        communications (except to recover tokens) with the NS SHALL be driven
        through this API.
        <p>
          On future releases will be supported another channels as Long-Polling
          solutions in order to cover devices which don't support Web Sockets.
        </p></li></ul></div><p>
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp219664"/>HTTP POST API</h4></div></div></div><p>
        This channel only offers one method to get a valid UAToken.
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp220768"/>GET UA TOKEN</h5></div></div></div><p>
          This method SHOULD be protected to avoid DoS attacks getting millions of
          valid tokens, in any case, this is out of the scope of this protocol.
        </p><p>
          The TOKEN method is called with a simple URL:
          <code class="code">https://&lt;notification_server_base_URL&gt;/token</code>
        </p><p>
          The server will respond with an AES encrypted valid token.
          This token SHALL be used to identify the device in future connections.
        </p></div></div><p>
    </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idp223664"/>WebSocket API</h4></div></div></div><p>
        Through this channel the device will register itself, his applications,
        and also will be used to deliver PUSH notifications
      </p><p>
        All methods sent through this channel will have the same JSON structure:
      </p><pre class="programlisting">
      
      {
        messageType: "&lt;type of message&gt;",
        ... other data ...
      }
      
      </pre><p>
        In which messageType defines one of these commands:
      </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp226512"/>registerUA</h5></div></div></div><p>
          With this method the device is able to register itself.
        </p><p>
          When a device is registering to a notification server, it SHALL send
          his own valid UAToken and also the device can send additional information
          that can be used to optimize the way the messages will be delivered
          to this device.
        </p><pre class="programlisting">
        
        {
          messageType: "registerUA",
          data: {
            uatoken: "&lt;a valid UAToken&gt;",
            interface: {
              ip: "&lt;current device IP address&gt;",
              port: "&lt;TCP or UDP port in which the device is waiting for wake up notifications&gt;"
            },
            mobilenetwork: {
              mcc: "&lt;Mobile Country Code&gt;",
              mnc: "&lt;Mobile Network Code&gt;"
            }
          }
        }
        
        </pre><p>
          The interface and mobilenetwork optional data will be used by the server
          to identify if it has the required infrastructure into the user's mobile
          network in order to send wakeup messages to the IP and port indicated
          in the interface data so it's able to close the WebSocket channel to reduce
          signalling and battery consume.
        </p><p>
          The server response can be:
          </p><pre class="programlisting">
          
          {
            status: "REGISTERED",
            statusCode: 200,
            messageType: "registerUA"
          }
          
          </pre><p>
          </p><pre class="programlisting">
          
          {
            status: "ERROR",
            statusCode: 40x,
            reason: "Data received is not a valid JSON package",
            messageType: "registerUA"
          }
          
          </pre><p>
          </p><pre class="programlisting">
          
          {
            status: "ERROR",
            statusCode: 40x,
            reason: "Token is not valid for this server",
            messageType: "registerUA"
          }
          
          </pre><p>
          </p><pre class="programlisting">
          
          {
            status: "ERROR",
            statusCode: 40x,
            reason: "...",
            messageType: "registerUA"
          }
          
          </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp233952"/>registerWA</h5></div></div></div><p>
          This method is used to register installed applications on the device.
          This shall be send to the notification server after a valid UA registration.
        </p><p>
          Normally, this method will be used each time an application requires a
          new push notification URL (through the WA-UA API) or also each time the
          device is powered on and is re-registering previously registered applications.
        </p><p>
          The required data for application registration is the WAToken and the
          public key.
        </p><pre class="programlisting">
        
        {
          messageType: "registerWA",
          data: {
            uatoken: "&lt;a valid UAToken&gt;",
            watoken: "&lt;the WAToken&gt;",
            pbkbase64: "&lt;BASE64 coded public key&gt;"
          }
        }
        
        </pre><p>
          The server response can be:
          </p><pre class="programlisting">
          
          {
            status: "REGISTERED",
            statusCode: 200,
            url: "&lt;publicURL required to send notifications&gt;",
            messageType: "registerUA"
          }
          
          </pre><p>
          </p><pre class="programlisting">
          
          {
            status: "ERROR",
            statusCode: 40x,
            reason: "...",
            messageType: "registerWA"
          }
          
          </pre><p>
        </p><p>
          The device service should redirect the received URL to the correct
          application.
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp239888"/>getAllMessages</h5></div></div></div><p>
          This method is used to retrieve all pending messages for one device.
        </p><p>
          This will be used each time the device is Waked Up, so it's polling
          pending messages.
        </p><pre class="programlisting">
        
        {
          messageType: "getAllMessages",
          data: {
            uatoken: "&lt;a valid UAToken&gt;"
          }
        }
        
        </pre><p>
          The server response can be:
          </p><pre class="programlisting">
          
          {
            messageType: "getAllMessages",
            [
              &lt;Array of notifications with the same format
               as defined in the notification method&gt;
            ]
          }
          
          </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp243728"/>notification</h5></div></div></div><p>
          This message will be used by the server to inform about new notification
          to the device.
        </p><p>
          All recieved notification will have this structure:
        </p><pre class="programlisting">
        
        {
          messageType: "notification",
          id: "&lt;ID used by the Application Server&gt;",
          message: "&lt;Message payload&gt;",
          timestamp: "&lt;Since EPOCH Time&gt;",
          priority: "&lt;prio&gt;",
          messageId: "&lt;ID of the message&gt;",
          url: "&lt;publicURL which identifies the final application&gt;"
        }
        
        </pre></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idp246448"/>ack</h5></div></div></div><p>
          For each received notification through notification or getAllMessages,
          the server SHOULD be notified in order to free resources related to
          this notifications.
        </p><p>
          This message is used to acknoledge the message reception.
        </p><pre class="programlisting">
          
          {
            messageType: "ack",
            messageId: "&lt;ID of the received message&gt;"
          }
          
          </pre></div></div><p>
  </p></div><div xml:lang="en" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="api_as_ns"/>API between the Application Server and the Notification Server</h2></div></div></div><p>
    With this API the Application server is able to send asynchronous notifications
    to his user's without heavy infrastructure requirements or complex technical skills.
  </p><p>
    This is a simple REST API which will be improved in future releases.
  </p><p>
    This version accepts only one HTTP POST method used to send the notification
    payload. The following payload SHALL be POSTED to the publicURL which defines
    the application and user, like:
    <code class="code">https://push.telefonica.es/notify/SOME_RANDOM_TOKEN</code>
    </p><pre class="programlisting">
    
    {
      messageType: "notification",
      id: "&lt;ID used by the Application Server&gt;",
      message: "&lt;Message payload&gt;",
      signature: "&lt;Signed message&gt;",
      ttl: "&lt;time to live&gt;",
      timestamp: "&lt;Since EPOCH Time&gt;",
      priority: "&lt;prio&gt;",
    }
    
    </pre><p>
  </p><p>
    The server response can be one of the following:
  </p><pre class="programlisting">
    STATUS: 200
    
    {
      status: "ACCEPTED"
    }
    
  </pre><pre class="programlisting">
    STATUS: 40x
    
    {
      status: "ERROR",
      reason: "JSON not valid"
    }
    
  </pre><pre class="programlisting">
    STATUS: 40x
    
    {
      status: "ERROR",
      reason: "Not messageType=notification"
    }
    
  </pre><pre class="programlisting">
    STATUS: 40x
    
    {
      status: "ERROR",
      reason: "Body too big"
    }
    
  </pre><pre class="programlisting">
    STATUS: 40x
    
    {
      status: "ERROR",
      reason: "You must sign your message with your Private Key"
    }
    
  </pre><pre class="programlisting">
    STATUS: 40x
    
    {
      status: "ERROR",
      reason: "Bad signature, dropping notification"
    }
    
  </pre><pre class="programlisting">
    STATUS: 40x
    
    {
      status: "ERROR",
      reason: "Try again later"
    }
    
  </pre><pre class="programlisting">
    STATUS: 40x
    
    {
      status: "ERROR",
      reason: "No valid AppToken"
    }
    
  </pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="api_wa_as"/>API between the WA and the AS</h2></div></div></div><p>
      This is a third party API which is independent of the PUSH protocol, so
      it's out of the scope of this document.
    </p><p>
      Anyway, through this API the publicURL received by the application should
      be send to his server.
    </p><p>
      Also this channel could be used to receive valid WATokens to be used during
      the WA registration.
    </p></div><div xml:lang="en" class="section"><div class="titlepage"><div><div><h2 class="title"><a id="api_tokens"/>Tokens</h2></div></div></div><p>
    The tokens are an important part of this API since it identifies each
    (user) actor (device and applications) in a unique or shared way.
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp265680"/>WAToken</h3></div></div></div><p>
      This token identifies the user or group of users and SHALL be a secret.
    </p><p>
      If this token is UNIQUE (and secret, of coures) will identify a unique
      instance of the application related (normally) to one user. In this case
      the returned URL will be unique for this WAToken.
    </p><p>
      If this token is shared by different devices of the SAME user (and secret),
      will identify a unique user with multiple devices. In this case, the returned
      URL will be unique per user but each URL will identify multiple devices
      the user is using.
    </p><div class="example"><a id="idp268080"/><p class="title"><strong>Example 3.1. Multiple device messages</strong></p><div class="example-contents"><p>
        This can be used by applications in which the user require the same
        information across his devices, like the mobile and the desktop app.
        Can be used, for example, by e-mail clients.
      </p></div></div><br class="example-break"/><p>
      Finally, if a developer decides to deliver the same WAToken to all his users
      (in this cases is obviously not a secret one), then the returned URL will
      identify all instances of the same application. In this case each notification
      received in the publicURL will be delivered to ALL the devices which have
      the application installed (and registered). This will be a BROADCAST message.
    </p><div class="example"><a id="idp270272"/><p class="title"><strong>Example 3.2. Message broadcast</strong></p><div class="example-contents"><p>
        This can be used by applications in which all users require exactly the
        same information at the same time, like weather applications, latest news, ...
      </p></div></div><br class="example-break"/></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp271728"/>UAToken</h3></div></div></div><p>
      This token identifies each customer device in a unique way.
    </p><p>
      This token is also used as an identification key since this isn't a random
      one. This token is an AES encrypted string which will be checked for
      validaty each time it's used.
    </p><p>
      This token should be delivered after identify the user in a valid way,
      anyway this identification procedure is out of the scope of this specification.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp274112"/>AppToken</h3></div></div></div><p>
      Automatic generated token by the notification server which identifies the
      application + user as in a unique fashion.
    </p><p>
      This token is included in the publicURL which identifies the application,
      and normally is a SHA256 hashed string with the WATokent + the Public Key.
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp276336"/>WakeUp</h2></div></div></div><p>
      When the handset is inside a mobile operator network, we can close the
      websocket to reduce battery comsuption and also network resources.
    </p><p>
      So, when the NS has messages to the WA installed on a concrete UA it will
      send a UDP Datagram to the handset.
    </p><p>
      When the mobile receives this datagram, it SHALL connect to the websocket
      interfaces in order to pull all pending messages.
    </p></div></div><div xml:lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="architecture"/>Chapter 4. Notification Server Architecture</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#idp162368">Technologies used</a></span></dt><dd><dl><dt><span class="section"><a href="#idp150880">MongoDB</a></span></dt><dt><span class="section"><a href="#idp73792">RabbitMQ</a></span></dt><dt><span class="section"><a href="#idp74816">Node.JS</a></span></dt></dl></dd><dt><span class="section"><a href="#idp75968">Types of servers</a></span></dt><dd><dl><dt><span class="section"><a href="#idp79008">NS-UA-WS</a></span></dt><dt><span class="section"><a href="#idp65776">NS-UA-UDP</a></span></dt><dt><span class="section"><a href="#idp67808">NS-WakeUp</a></span></dt><dt><span class="section"><a href="#idp70704">NS-AS</a></span></dt><dt><span class="section"><a href="#idp165616">NS-Monitor</a></span></dt><dt><span class="section"><a href="#idp167696">Message Queue (RabbitMQ)</a></span></dt><dt><span class="section"><a href="#idp169872">NO-SQL Database (MongoDB)</a></span></dt></dl></dd></dl></div><p>
    This chapter explains how is the server designed to be able to process
    millions of messages per second.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp162368"/>Technologies used</h2></div></div></div><p>
      The server infrastructure had been build using high performance languages
      and also high performance database and message queuing systems.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp150880"/>MongoDB</h3></div></div></div><p/></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp73792"/>RabbitMQ</h3></div></div></div><p/></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp74816"/>Node.JS</h3></div></div></div><p/></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idp75968"/>Types of servers</h2></div></div></div><p>
      In order to be able to scale horizontally and vertically with no limits
      all the server platform infrastructure had been splitted in several boxes
      one of them dedicated to a particular task and also independent of the
      rest so it can be scalled independently of the rest ones.
    </p><p>
        The names of each box follows this scheme:
        NS-&lt;type_of_client&gt;
    </p><p>
      <img src="resources/ns_servers.png" style="text-align: middle" width="450"/>
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp79008"/>NS-UA-WS</h3></div></div></div><p>
          The NS_UA_WS server is the frontend for mobile devices.
          This server will attend the clients using HTTP protocols
          (HTTP GET and WebSockets)  
        </p><p>
          This server offers to channels:
          </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
              Retrieve a valid User Agent token used to identify each handset.
              This token will be delivered via HTTP GET method to
              the /token URL.
            </li><li class="listitem"><p>
                Maintain a Websocket connection with the clients.
                This WebSocket will be maintained open in order to deliver push
                messages through it.
              </p><p>
                This server will store on the MongoDB all registered nodes and
                applications. Also will receive from the Message Queue all the
                messages to be delivered to the connected handsets.
              </p></li></ul></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp65776"/>NS-UA-UDP</h3></div></div></div><p>
          The NS_UA_UDP server is the responsible to intermediate between the
          central Notification Server infrastructure and each NS_WakeUp
          deployed in each OB.
        </p><p>
          As told before, this server will be connected to the message queue
          and for each received wake-up petition this server will retrieve from
          the MongoDB the NS_WakeUp server address and send a HTTP message to
          it querying to wake-up a handset.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp67808"/>NS-WakeUp</h3></div></div></div><p>
          The NS_WakeUp server is a proxy between the central NS servers and
          the client equipment (device). This service will receive petitions
          through a standard HTTP port and will send UDP datagrams or TCP packets
          (for pinging purposes) inside the OB private network to the private
          IP of the client equipment. This server must be placed inside the OB
          private network or in a zone that must see that private IPs.
        </p><p>
          The Wake-Up Proxy server is responsible to ping to the correct
          client inside each OB (using UDP datagrams). It must be placed inside
          the OB or in a zone that can see the devices inside that
          private network.
        </p><p>
          This server will receive the ping orders through a standard HTTP
          port which will be connected to InterNodo network to receive the
          data from the VDC inside Telefónica network.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp70704"/>NS-AS</h3></div></div></div><p>
          The NS_AS server is the frontend for application servers. This server
          will attend the third party servers through HTTPS POST petitions.
        </p><p>
          This server will expose a HTTPS POST in /notify method in order to
          receive messages from the third party application servers.
          The received messages will be stored on the MongoDB and will notify
          other servers through the Message Queue.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp165616"/>NS-Monitor</h3></div></div></div><p>
          The NS_Monitor is the responsible to deliver messages to the correct
          recipient. So this server will be monitoring all inbound messages,
          deliver them and verify if re-deliver is needed.
        </p><p>
          The monitor reads the /newMessage queue (which frontends from the
          NS_AS puts all the received messages), and finds in the database
          which nodes need to be notified, sending the message to the correct
          queue the node (user agent) is subscribed to.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp167696"/>Message Queue (RabbitMQ)</h3></div></div></div><p>
          A Message Queue cluster is used to act as a message dispatcher
          between all the other servers. RabbitMQ or ActiveMQ will be used.
        </p><p>
          This is a standard Message Queue which supports STOMP or AMQP protocol.
        </p><p>
          Because huge load, this server will be deployed in cluster mode.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idp169872"/>NO-SQL Database (MongoDB)</h3></div></div></div><p>
          A MongoDB cluster is needed to use as persistent storage system.
          It is used to save the registered devices, registered apps and
          received messages.
        </p><p>
          This is a non relational database.
        </p><p>
          Because huge load, this server will be deployed in cluster mode.
        </p></div></div></div><div xml:lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="performance"/>Chapter 5. Notification Server Performance</h1></div></div></div><p>
    This chapter shows some performance test done to the notification server
  </p></div><div xml:lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="deployment"/>Chapter 6. Notification Server Deployment</h1></div></div></div><p>
    This chapter explains how is the notification server will be deployed
  </p></div><div xml:lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="lessons_learned"/>Chapter 7. Lessons learned</h1></div></div></div><p>
    In this chapter we will explain the lessons we learned during the daily work
    in a high scalable and high performance server infrastructure
  </p></div></div></body></html>
